{"ast":null,"code":"import { parse, format, resolve } from 'url';\nimport * as http from 'http';\nimport { STATUS_CODES } from 'http';\nimport * as https from 'https';\nimport * as zlib from 'zlib';\nimport Stream, { PassThrough } from 'stream';\nimport { convert } from 'encoding';\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\n// Based on https://github.com/tmpvar/jsdom/blob/aa85b2abf07766ff7bf5c1f6daafb3726f2f2db5/lib/jsdom/living/blob.js\n// (MIT licensed)\nconst BUFFER = Symbol('buffer');\nconst TYPE = Symbol('type');\nconst CLOSED = Symbol('closed');\nclass Blob {\n  constructor() {\n    Object.defineProperty(this, Symbol.toStringTag, {\n      value: 'Blob',\n      writable: false,\n      enumerable: false,\n      configurable: true\n    });\n    this[CLOSED] = false;\n    this[TYPE] = '';\n    const blobParts = arguments[0];\n    const options = arguments[1];\n    const buffers = [];\n    if (blobParts) {\n      const a = blobParts;\n      const length = Number(a.length);\n      for (let i = 0; i < length; i++) {\n        const element = a[i];\n        let buffer;\n        if (element instanceof Buffer) {\n          buffer = element;\n        } else if (ArrayBuffer.isView(element)) {\n          buffer = Buffer.from(new Uint8Array(element.buffer, element.byteOffset, element.byteLength));\n        } else if (element instanceof ArrayBuffer) {\n          buffer = Buffer.from(new Uint8Array(element));\n        } else if (element instanceof Blob) {\n          buffer = element[BUFFER];\n        } else {\n          buffer = Buffer.from(typeof element === 'string' ? element : String(element));\n        }\n        buffers.push(buffer);\n      }\n    }\n    this[BUFFER] = Buffer.concat(buffers);\n    const type = options && options.type !== undefined && String(options.type).toLowerCase();\n    if (type && !/[^\\u0020-\\u007E]/.test(type)) {\n      this[TYPE] = type;\n    }\n  }\n  get size() {\n    return this[CLOSED] ? 0 : this[BUFFER].length;\n  }\n  get type() {\n    return this[TYPE];\n  }\n  get isClosed() {\n    return this[CLOSED];\n  }\n  slice() {\n    const size = this.size;\n    const start = arguments[0];\n    const end = arguments[1];\n    let relativeStart, relativeEnd;\n    if (start === undefined) {\n      relativeStart = 0;\n    } else if (start < 0) {\n      relativeStart = Math.max(size + start, 0);\n    } else {\n      relativeStart = Math.min(start, size);\n    }\n    if (end === undefined) {\n      relativeEnd = size;\n    } else if (end < 0) {\n      relativeEnd = Math.max(size + end, 0);\n    } else {\n      relativeEnd = Math.min(end, size);\n    }\n    const span = Math.max(relativeEnd - relativeStart, 0);\n    const buffer = this[BUFFER];\n    const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);\n    const blob = new Blob([], {\n      type: arguments[2]\n    });\n    blob[BUFFER] = slicedBuffer;\n    blob[CLOSED] = this[CLOSED];\n    return blob;\n  }\n  close() {\n    this[CLOSED] = true;\n  }\n}\nObject.defineProperty(Blob.prototype, Symbol.toStringTag, {\n  value: 'BlobPrototype',\n  writable: false,\n  enumerable: false,\n  configurable: true\n});\n\n/**\n * fetch-error.js\n *\n * FetchError interface for operational errors\n */\n\n/**\n * Create FetchError instance\n *\n * @param {string} message Error message for human\n * @param {string} type Error type for machine\n * @param {string} systemError For Node.js system error\n * @return {FetchError}\n */\nconst netErrorMap = {\n  ERR_CONNECTION_REFUSED: 'ECONNREFUSED',\n  ERR_EMPTY_RESPONSE: 'ECONNRESET',\n  ERR_NAME_NOT_RESOLVED: 'ENOTFOUND',\n  ERR_CONTENT_DECODING_FAILED: 'Z_DATA_ERROR',\n  ERR_CONTENT_DECODING_INIT_FAILED: 'Z_DATA_ERROR'\n};\nfunction FetchError(message, type, systemError) {\n  Error.call(this, message);\n  const regex = /^.*net::(.*)/;\n  if (regex.test(message)) {\n    let errorCode = regex.exec(message)[1]; // istanbul ignore else\n\n    if (Object.prototype.hasOwnProperty.call(netErrorMap, errorCode)) errorCode = netErrorMap[errorCode];\n    systemError = {\n      code: errorCode\n    };\n  }\n  this.message = message;\n  this.type = type; // when err.type is `system`, err.code contains system error code\n\n  if (systemError) {\n    this.code = this.errno = systemError.code;\n  } // hide custom error implementation details from end-users\n\n  Error.captureStackTrace(this, this.constructor);\n}\nFetchError.prototype = Object.create(Error.prototype);\nFetchError.prototype.constructor = FetchError;\nFetchError.prototype.name = 'FetchError';\nconst DISTURBED = Symbol('disturbed');\n/**\n * Body class\n *\n * Cannot use ES6 class because Body must be called with .call().\n *\n * @param {Stream|string|Blob|Buffer|null} body Readable stream\n * @param {number} size\n * @param {number} timeout\n */\n\nfunction Body(body, {\n  size = 0,\n  timeout = 0\n} = {}) {\n  if (body == null) {\n    // body is undefined or null\n    body = null;\n  } else if (typeof body === 'string') ;else if (body instanceof Blob) ;else if (Buffer.isBuffer(body)) ;else if (body instanceof Stream) ;else {\n    // none of the above\n    // coerce to string\n    body = String(body);\n  }\n  this.body = body;\n  this[DISTURBED] = false;\n  this.size = size;\n  this.timeout = timeout;\n}\nBody.prototype = {\n  get bodyUsed() {\n    return this[DISTURBED];\n  },\n  /**\n   * Decode response as ArrayBuffer\n   *\n   * @return {Promise}\n   */\n  arrayBuffer() {\n    return consumeBody.call(this).then(buf => buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength));\n  },\n  /**\n   * Return raw response as Blob\n   *\n   * @return {Promise}\n   */\n  blob() {\n    const ct = this.headers && this.headers.get('content-type') || '';\n    return consumeBody.call(this).then(buf => Object.assign(\n    // Prevent copying\n    new Blob([], {\n      type: ct.toLowerCase()\n    }), {\n      [BUFFER]: buf\n    }));\n  },\n  /**\n   * Decode response as json\n   *\n   * @return {Promise}\n   */\n  json() {\n    return consumeBody.call(this).then(buffer => JSON.parse(buffer.toString()));\n  },\n  /**\n   * Decode response as text\n   *\n   * @return {Promise}\n   */\n  text() {\n    return consumeBody.call(this).then(buffer => buffer.toString());\n  },\n  /**\n   * Decode response as buffer (non-spec api)\n   *\n   * @return {Promise}\n   */\n  buffer() {\n    return consumeBody.call(this);\n  },\n  /**\n   * Decode response as text, while automatically detecting the encoding and\n   * trying to decode to UTF-8 (non-spec api)\n   *\n   * @return {Promise}\n   */\n  textConverted() {\n    return consumeBody.call(this).then(buffer => convertBody(buffer, this.headers));\n  }\n};\nBody.mixIn = function (proto) {\n  for (var _iterator = _createForOfIteratorHelperLoose(Object.getOwnPropertyNames(Body.prototype)), _step; !(_step = _iterator()).done;) {\n    const name = _step.value;\n\n    // istanbul ignore else\n    if (!(name in proto)) {\n      const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);\n      Object.defineProperty(proto, name, desc);\n    }\n  }\n};\n/**\n * Decode buffers into utf-8 string\n *\n * @return {Promise}\n */\n\nfunction consumeBody() {\n  if (this[DISTURBED]) {\n    return Promise.reject(new Error(`body used already for: ${this.url}`));\n  }\n  this[DISTURBED] = true; // body is null\n\n  if (this.body === null) {\n    return Promise.resolve(Buffer.alloc(0));\n  } // body is string\n\n  if (typeof this.body === 'string') {\n    return Promise.resolve(Buffer.from(this.body));\n  } // body is blob\n\n  if (this.body instanceof Blob) {\n    return Promise.resolve(this.body[BUFFER]);\n  } // body is buffer\n\n  if (Buffer.isBuffer(this.body)) {\n    return Promise.resolve(this.body);\n  } // istanbul ignore if: should never happen\n\n  if (!(this.body instanceof Stream)) {\n    return Promise.resolve(Buffer.alloc(0));\n  } // body is stream\n  // get ready to actually consume the body\n\n  const accum = [];\n  let accumBytes = 0;\n  let abort = false;\n  return new Promise((resolve, reject) => {\n    let resTimeout; // allow timeout on slow response body\n\n    if (this.timeout) {\n      resTimeout = setTimeout(() => {\n        abort = true;\n        reject(new FetchError(`Response timeout while trying to fetch ${this.url} (over ${this.timeout}ms)`, 'body-timeout'));\n        this.body.emit('cancel-request');\n      }, this.timeout);\n    } // handle stream error, such as incorrect content-encoding\n\n    this.body.on('error', err => {\n      reject(new FetchError(`Invalid response body while trying to fetch ${this.url}: ${err.message}`, 'system', err));\n    });\n    this.body.on('data', chunk => {\n      if (abort || chunk === null) {\n        return;\n      }\n      if (this.size && accumBytes + chunk.length > this.size) {\n        abort = true;\n        reject(new FetchError(`content size at ${this.url} over limit: ${this.size}`, 'max-size'));\n        this.body.emit('cancel-request');\n        return;\n      }\n      accumBytes += chunk.length;\n      accum.push(chunk);\n    });\n    this.body.on('end', () => {\n      if (abort) {\n        return;\n      }\n      clearTimeout(resTimeout);\n      resolve(Buffer.concat(accum));\n    });\n  });\n}\n/**\n * Detect buffer encoding and convert to target encoding\n * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding\n *\n * @param {Buffer} buffer   Incoming buffer\n * @param {Headers} headers\n * @return {string}\n */\n\nfunction convertBody(buffer, headers) {\n  const ct = headers.get('content-type');\n  let charset = 'utf-8';\n  let res; // header\n\n  if (ct) {\n    res = /charset=([^;]*)/i.exec(ct);\n  } // no charset in content type, peek at response body for at most 1024 bytes\n\n  const str = buffer.slice(0, 1024).toString(); // html5\n\n  if (!res && str) {\n    res = /<meta.+?charset=(['\"])(.+?)\\1/i.exec(str);\n  } // html4\n\n  if (!res && str) {\n    res = /<meta[\\s]+?http-equiv=(['\"])content-type\\1[\\s]+?content=(['\"])(.+?)\\2/i.exec(str);\n    if (res) {\n      res = /charset=(.*)/i.exec(res.pop());\n    }\n  } // xml\n\n  if (!res && str) {\n    res = /<\\?xml.+?encoding=(['\"])(.+?)\\1/i.exec(str);\n  } // found charset\n\n  if (res) {\n    charset = res.pop(); // prevent decode issues when sites use incorrect encoding\n    // ref: https://hsivonen.fi/encoding-menu/\n\n    if (charset === 'gb2312' || charset === 'gbk') {\n      charset = 'gb18030';\n    }\n  } // turn raw buffers into a single utf-8 buffer\n\n  return convert(buffer, 'UTF-8', charset).toString();\n}\n/**\n * Clone body given Res/Req instance\n *\n * @param {Response|Request} instance Response or Request instance\n * @return {string|Blob|Buffer|Stream}\n */\n\nfunction clone(instance) {\n  let p1, p2;\n  let body = instance.body; // don't allow cloning a used body\n\n  if (instance.bodyUsed) {\n    throw new Error('cannot clone body after it is used');\n  } // check that body is a stream and not form-data object\n  // note: we can't clone the form-data object without having it as a dependency\n\n  if (body instanceof Stream && typeof body.getBoundary !== 'function') {\n    // tee instance body\n    p1 = new PassThrough();\n    p2 = new PassThrough();\n    body.pipe(p1);\n    body.pipe(p2); // set instance body to teed body and return the other teed body\n\n    instance.body = p1;\n    body = p2;\n  }\n  return body;\n}\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present and non-null.\n *\n * @param {Response|Request} instance Response or Request instance\n */\n\nfunction extractContentType(instance) {\n  const body = instance.body; // istanbul ignore if: Currently, because of a guard in Request, body\n  // can never be null. Included here for completeness.\n\n  if (body === null) {\n    // body is null\n    return null;\n  } else if (typeof body === 'string') {\n    // body is string\n    return 'text/plain;charset=UTF-8';\n  } else if (body instanceof Blob) {\n    // body is blob\n    return body.type || null;\n  } else if (Buffer.isBuffer(body)) {\n    // body is buffer\n    return null;\n  } else if (typeof body.getBoundary === 'function') {\n    // detect form data input from form-data module\n    return `multipart/form-data;boundary=${body.getBoundary()}`;\n  } else {\n    // body is stream\n    // can't really do much about this\n    return null;\n  }\n}\nfunction getTotalBytes(instance) {\n  const body = instance.body; // istanbul ignore if: included for completion\n\n  if (body === null) {\n    // body is null\n    return 0;\n  } else if (typeof body === 'string') {\n    // body is string\n    return Buffer.byteLength(body);\n  } else if (body instanceof Blob) {\n    // body is blob\n    return body.size;\n  } else if (Buffer.isBuffer(body)) {\n    // body is buffer\n    return body.length;\n  } else if (body && typeof body.getLengthSync === 'function') {\n    // detect form data input from form-data module\n    // istanbul ignore next\n    if (body._lengthRetrievers && body._lengthRetrievers.length === 0 ||\n    // 1.x\n    body.hasKnownLength && body.hasKnownLength()) {\n      // 2.x\n      return body.getLengthSync();\n    }\n    return null;\n  } else {\n    // body is stream\n    // can't really do much about this\n    return null;\n  }\n}\nfunction writeToStream(dest, instance) {\n  const body = instance.body;\n  if (body === null) {\n    // body is null\n    dest.end();\n  } else if (typeof body === 'string') {\n    // body is string\n    dest.write(body);\n    dest.end();\n  } else if (body instanceof Blob) {\n    // body is blob\n    dest.write(body[BUFFER]);\n    dest.end();\n  } else if (Buffer.isBuffer(body)) {\n    // body is buffer\n    dest.write(body);\n    dest.end();\n  } else {\n    // body is stream\n    if (instance.useElectronNet) {\n      dest.chunkedEncoding = instance.chunkedEncoding; // Force a first write to start the request otherwise an empty body stream\n      // will cause an error when closing the dest stream with Electron v7.\n\n      dest.write('');\n    }\n    body.pipe(new PassThrough()) // I have to put a PassThrough because somehow, FormData streams are not eaten by electron/net\n    .pipe(dest);\n  }\n}\n\n/**\n * A set of utilities borrowed from Node.js' _http_common.js\n */\n\n/**\n * Verifies that the given val is a valid HTTP token\n * per the rules defined in RFC 7230\n * See https://tools.ietf.org/html/rfc7230#section-3.2.6\n *\n * Allowed characters in an HTTP token:\n * ^_`a-z  94-122\n * A-Z     65-90\n * -       45\n * 0-9     48-57\n * !       33\n * #$%&'   35-39\n * *+      42-43\n * .       46\n * |       124\n * ~       126\n *\n * This implementation of checkIsHttpToken() loops over the string instead of\n * using a regular expression since the former is up to 180% faster with v8 4.9\n * depending on the string length (the shorter the string, the larger the\n * performance difference)\n *\n * Additionally, checkIsHttpToken() is currently designed to be inlinable by v8,\n * so take care when making changes to the implementation so that the source\n * code size does not exceed v8's default max_inlined_source_size setting.\n **/\n// istanbul ignore next\nfunction isValidTokenChar(ch) {\n  if (ch >= 94 && ch <= 122) {\n    return true;\n  }\n  if (ch >= 65 && ch <= 90) {\n    return true;\n  }\n  if (ch === 45) {\n    return true;\n  }\n  if (ch >= 48 && ch <= 57) {\n    return true;\n  }\n  if (ch === 34 || ch === 40 || ch === 41 || ch === 44) {\n    return false;\n  }\n  if (ch >= 33 && ch <= 46) {\n    return true;\n  }\n  if (ch === 124 || ch === 126) {\n    return true;\n  }\n  return false;\n} // istanbul ignore next\n\nfunction checkIsHttpToken(val) {\n  if (typeof val !== 'string' || val.length === 0) {\n    return false;\n  }\n  if (!isValidTokenChar(val.charCodeAt(0))) {\n    return false;\n  }\n  const len = val.length;\n  if (len > 1) {\n    if (!isValidTokenChar(val.charCodeAt(1))) {\n      return false;\n    }\n    if (len > 2) {\n      if (!isValidTokenChar(val.charCodeAt(2))) {\n        return false;\n      }\n      if (len > 3) {\n        if (!isValidTokenChar(val.charCodeAt(3))) {\n          return false;\n        }\n        for (let i = 4; i < len; i++) {\n          if (!isValidTokenChar(val.charCodeAt(i))) {\n            return false;\n          }\n        }\n      }\n    }\n  }\n  return true;\n}\n/**\n * True if val contains an invalid field-vchar\n *  field-value    = *( field-content / obs-fold )\n *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n *  field-vchar    = VCHAR / obs-text\n *\n * checkInvalidHeaderChar() is currently designed to be inlinable by v8,\n * so take care when making changes to the implementation so that the source\n * code size does not exceed v8's default max_inlined_source_size setting.\n **/\n// istanbul ignore next\n\nfunction checkInvalidHeaderChar(val) {\n  val += '';\n  if (val.length < 1) {\n    return false;\n  }\n  let c = val.charCodeAt(0);\n  if (c <= 31 && c !== 9 || c > 255 || c === 127) {\n    return true;\n  }\n  if (val.length < 2) {\n    return false;\n  }\n  c = val.charCodeAt(1);\n  if (c <= 31 && c !== 9 || c > 255 || c === 127) {\n    return true;\n  }\n  if (val.length < 3) {\n    return false;\n  }\n  c = val.charCodeAt(2);\n  if (c <= 31 && c !== 9 || c > 255 || c === 127) {\n    return true;\n  }\n  for (let i = 3; i < val.length; ++i) {\n    c = val.charCodeAt(i);\n    if (c <= 31 && c !== 9 || c > 255 || c === 127) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction sanitizeName(name) {\n  name += '';\n  if (!checkIsHttpToken(name)) {\n    throw new TypeError(`${name} is not a legal HTTP header name`);\n  }\n  return name.toLowerCase();\n}\nfunction sanitizeValue(value) {\n  value += '';\n  if (checkInvalidHeaderChar(value)) {\n    throw new TypeError(`${value} is not a legal HTTP header value`);\n  }\n  return value;\n}\nconst MAP = Symbol('map');\nclass Headers {\n  /**\n   * Headers class\n   *\n   * @param {Object} init Response headers\n   */\n  constructor(init = undefined) {\n    this[MAP] = Object.create(null); // We don't worry about converting prop to ByteString here as append()\n    // will handle it.\n\n    if (init == null) ;else if (typeof init === 'object') {\n      const method = init[Symbol.iterator];\n      if (method != null) {\n        if (typeof method !== 'function') {\n          throw new TypeError('Header pairs must be iterable');\n        } // sequence<sequence<ByteString>>\n        // Note: per spec we have to first exhaust the lists then process them\n\n        const pairs = [];\n        for (var _iterator = _createForOfIteratorHelperLoose(init), _step; !(_step = _iterator()).done;) {\n          const pair = _step.value;\n          if (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') {\n            throw new TypeError('Each header pair must be iterable');\n          }\n          pairs.push(Array.from(pair));\n        }\n        for (var _i = 0, _pairs = pairs; _i < _pairs.length; _i++) {\n          const pair = _pairs[_i];\n          if (pair.length !== 2) {\n            throw new TypeError('Each header pair must be a name/value tuple');\n          }\n          this.append(pair[0], pair[1]);\n        }\n      } else {\n        // record<ByteString, ByteString>\n        for (var _i2 = 0, _Object$keys = Object.keys(init); _i2 < _Object$keys.length; _i2++) {\n          const key = _Object$keys[_i2];\n          const value = init[key];\n          this.append(key, value);\n        }\n      }\n    } else {\n      throw new TypeError('Provided initializer must be an object');\n    }\n    Object.defineProperty(this, Symbol.toStringTag, {\n      value: 'Headers',\n      writable: false,\n      enumerable: false,\n      configurable: true\n    });\n  }\n  /**\n   * Return first header value given name\n   *\n   * @param {string} name Header name\n   * @return {string}\n   */\n\n  get(name) {\n    const list = this[MAP][sanitizeName(name)];\n    if (!list) {\n      return null;\n    }\n    return list.join(',');\n  }\n  /**\n   * Iterate over all headers\n   *\n   * @param {function} callback Executed for each item with parameters (value, name, thisArg)\n   * @param {boolean} thisArg `this` context for callback function\n   */\n\n  forEach(callback, thisArg = undefined) {\n    let pairs = getHeaderPairs(this);\n    let i = 0;\n    while (i < pairs.length) {\n      const _pairs$i = pairs[i],\n        name = _pairs$i[0],\n        value = _pairs$i[1];\n      callback.call(thisArg, value, name, this);\n      pairs = getHeaderPairs(this);\n      i++;\n    }\n  }\n  /**\n   * Overwrite header values given name\n   *\n   * @param {string} name Header name\n   * @param {string|Array.<string|*>|*} value Header value\n   */\n\n  set(name, value) {\n    this[MAP][sanitizeName(name)] = [sanitizeValue(value)];\n  }\n  /**\n   * Append a value onto existing header\n   *\n   * @param {string} name Header name\n   * @param {string|Array.<string|*>|*} value Header value\n   */\n\n  append(name, value) {\n    if (!this.has(name)) {\n      this.set(name, value);\n      return;\n    }\n    this[MAP][sanitizeName(name)].push(sanitizeValue(value));\n  }\n  /**\n   * Check for header name existence\n   *\n   * @param {string} name Header name\n   * @return {boolean}\n   */\n\n  has(name) {\n    return !!this[MAP][sanitizeName(name)];\n  }\n  /**\n   * Delete all header values given name\n   *\n   * @param {string} name Header name\n   */\n\n  delete(name) {\n    delete this[MAP][sanitizeName(name)];\n  }\n  /**\n   * Return raw headers (non-spec api)\n   *\n   * @return {Object}\n   */\n\n  raw() {\n    return this[MAP];\n  }\n  /**\n   * Get an iterator on keys.\n   *\n   * @return {Iterator}\n   */\n\n  keys() {\n    return createHeadersIterator(this, 'key');\n  }\n  /**\n   * Get an iterator on values.\n   *\n   * @return {Iterator}\n   */\n\n  values() {\n    return createHeadersIterator(this, 'value');\n  }\n  /**\n   * Get an iterator on entries.\n   *\n   * This is the default iterator of the Headers object.\n   *\n   * @return {Iterator}\n   */\n\n  [Symbol.iterator]() {\n    return createHeadersIterator(this, 'key+value');\n  }\n}\nHeaders.prototype.entries = Headers.prototype[Symbol.iterator];\nObject.defineProperty(Headers.prototype, Symbol.toStringTag, {\n  value: 'HeadersPrototype',\n  writable: false,\n  enumerable: false,\n  configurable: true\n});\nfunction getHeaderPairs(headers, kind) {\n  if (kind === 'key') return Object.keys(headers[MAP]).sort().map(k => [k]);\n  const pairs = [];\n  for (var _iterator2 = _createForOfIteratorHelperLoose(Object.keys(headers[MAP]).sort()), _step2; !(_step2 = _iterator2()).done;) {\n    const key = _step2.value;\n    for (var _iterator3 = _createForOfIteratorHelperLoose(headers[MAP][key]), _step3; !(_step3 = _iterator3()).done;) {\n      const value = _step3.value;\n      pairs.push([key, value]);\n    }\n  }\n  return pairs;\n}\nconst INTERNAL = Symbol('internal');\nfunction createHeadersIterator(target, kind) {\n  const iterator = Object.create(HeadersIteratorPrototype);\n  iterator[INTERNAL] = {\n    target,\n    kind,\n    index: 0\n  };\n  return iterator;\n}\nconst HeadersIteratorPrototype = Object.setPrototypeOf({\n  next() {\n    // istanbul ignore if\n    if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {\n      throw new TypeError('Value of `this` is not a HeadersIterator');\n    }\n    const _this$INTERNAL = this[INTERNAL],\n      target = _this$INTERNAL.target,\n      kind = _this$INTERNAL.kind,\n      index = _this$INTERNAL.index;\n    const values = getHeaderPairs(target, kind);\n    const len = values.length;\n    if (index >= len) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n    const pair = values[index];\n    this[INTERNAL].index = index + 1;\n    let result;\n    if (kind === 'key') {\n      result = pair[0];\n    } else if (kind === 'value') {\n      result = pair[1];\n    } else {\n      result = pair;\n    }\n    return {\n      value: result,\n      done: false\n    };\n  }\n}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));\nObject.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {\n  value: 'HeadersIterator',\n  writable: false,\n  enumerable: false,\n  configurable: true\n});\n\n/**\n * response.js\n *\n * Response class provides content decoding\n */\n/**\n * Response class\n *\n * @param {Stream} body Readable stream\n * @param {Object} opts Response options\n */\n\nclass Response {\n  constructor(body = null, opts = {}) {\n    Body.call(this, body, opts);\n    this.url = opts.url;\n    this.status = opts.status || 200;\n    this.statusText = opts.statusText || STATUS_CODES[this.status];\n    this.headers = new Headers(opts.headers);\n    this.useElectronNet = opts.useElectronNet;\n    Object.defineProperty(this, Symbol.toStringTag, {\n      value: 'Response',\n      writable: false,\n      enumerable: false,\n      configurable: true\n    });\n  }\n  /**\n   * Convenience property representing if the request ended normally\n   */\n\n  get ok() {\n    return this.status >= 200 && this.status < 300;\n  }\n  /**\n   * Clone this response\n   *\n   * @return {Response}\n   */\n\n  clone() {\n    return new Response(clone(this), {\n      url: this.url,\n      status: this.status,\n      statusText: this.statusText,\n      headers: this.headers,\n      ok: this.ok,\n      useElectronNet: this.useElectronNet\n    });\n  }\n}\nBody.mixIn(Response.prototype);\nObject.defineProperty(Response.prototype, Symbol.toStringTag, {\n  value: 'ResponsePrototype',\n  writable: false,\n  enumerable: false,\n  configurable: true\n});\n\n/**\n * request.js\n *\n * Request class contains server only options\n */\nconst PARSED_URL = Symbol('url');\n/**\n * Request class\n *\n * @param {string|Request} input Url or Request instance\n * @param {Object} init Custom options\n */\n\nclass Request {\n  constructor(input, init = {}) {\n    let parsedURL; // normalize input\n\n    if (!(input instanceof Request)) {\n      if (input && input.href) {\n        // in order to support Node.js' Url objects; though WHATWG's URL objects\n        // will fall into this branch also (since their `toString()` will return\n        // `href` property anyway)\n        parsedURL = parse(input.href);\n      } else {\n        // coerce input to a string before attempting to parse\n        parsedURL = parse(`${input}`);\n      }\n      input = {};\n    } else {\n      parsedURL = parse(input.url);\n    }\n    const method = init.method || input.method || 'GET';\n    if ((init.body != null || input instanceof Request && input.body !== null) && (method === 'GET' || method === 'HEAD')) {\n      throw new TypeError('Request with GET/HEAD method cannot have body');\n    }\n    const inputBody = init.body != null ? init.body : input instanceof Request && input.body !== null ? clone(input) : null;\n    Body.call(this, inputBody, {\n      timeout: init.timeout || input.timeout || 0,\n      size: init.size || input.size || 0\n    }); // fetch spec options\n\n    this.method = method.toUpperCase();\n    this.redirect = init.redirect || input.redirect || 'follow';\n    this.signal = init.signal || input.signal || null;\n    this.headers = new Headers(init.headers || input.headers || {});\n    this.headers.delete('Content-Length'); // user cannot set content-length themself as per fetch spec\n\n    this.chunkedEncoding = false;\n    this.useElectronNet = init.useElectronNet !== undefined // have to do this instead of || because it can be set to false\n    ? init.useElectronNet : input.useElectronNet; // istanbul ignore if\n\n    if (this.useElectronNet && !process.versions.electron) throw new Error('Cannot use Electron/net module on Node.js!');\n    if (this.useElectronNet === undefined) {\n      this.useElectronNet = Boolean(process.versions.electron);\n    }\n    if (this.useElectronNet) {\n      this.useSessionCookies = init.useSessionCookies !== undefined ? init.useSessionCookies : input.useSessionCookies;\n    }\n    if (init.body != null) {\n      const contentType = extractContentType(this);\n      if (contentType !== null && !this.headers.has('Content-Type')) {\n        this.headers.append('Content-Type', contentType);\n      }\n    } // server only options\n\n    this.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;\n    this.counter = init.counter || input.counter || 0;\n    this.session = init.session || input.session;\n    this[PARSED_URL] = parsedURL;\n    Object.defineProperty(this, Symbol.toStringTag, {\n      value: 'Request',\n      writable: false,\n      enumerable: false,\n      configurable: true\n    });\n  }\n  get url() {\n    return format(this[PARSED_URL]);\n  }\n  /**\n   * Clone this request\n   *\n   * @return {Request}\n   */\n\n  clone() {\n    return new Request(this);\n  }\n}\nBody.mixIn(Request.prototype);\nObject.defineProperty(Request.prototype, Symbol.toStringTag, {\n  value: 'RequestPrototype',\n  writable: false,\n  enumerable: false,\n  configurable: true\n});\nfunction getNodeRequestOptions(request) {\n  const parsedURL = request[PARSED_URL];\n  const headers = new Headers(request.headers); // fetch step 3\n\n  if (!headers.has('Accept')) {\n    headers.set('Accept', '*/*');\n  } // Basic fetch\n\n  if (!parsedURL.protocol || !parsedURL.hostname) {\n    throw new TypeError('Only absolute URLs are supported');\n  }\n  if (!/^https?:$/.test(parsedURL.protocol)) {\n    throw new TypeError('Only HTTP(S) protocols are supported');\n  } // HTTP-network-or-cache fetch steps 5-9\n\n  let contentLengthValue = null;\n  if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {\n    contentLengthValue = '0';\n  }\n  if (request.body != null) {\n    const totalBytes = getTotalBytes(request);\n    if (typeof totalBytes === 'number') {\n      contentLengthValue = String(totalBytes);\n    }\n  }\n  if (contentLengthValue) {\n    if (!request.useElectronNet) headers.set('Content-Length', contentLengthValue);\n  } else {\n    request.chunkedEncoding = true;\n  } // HTTP-network-or-cache fetch step 12\n\n  if (!headers.has('User-Agent')) {\n    headers.set('User-Agent', `electron-fetch/1.0 ${request.useElectronNet ? 'electron' : 'node'} (+https://github.com/arantes555/electron-fetch)`);\n  } // HTTP-network-or-cache fetch step 16\n\n  headers.set('Accept-Encoding', 'gzip,deflate');\n  if (!headers.has('Connection')) {\n    headers.set('Connection', 'close');\n  } // HTTP-network fetch step 4\n  // chunked encoding is handled by Node.js when not running in electron\n\n  return Object.assign({}, parsedURL, {\n    method: request.method,\n    headers: headers.raw()\n  });\n}\nlet electron; // istanbul ignore else\n\nif (process.versions.electron) {\n  electron = require('electron');\n}\nconst isReady = electron && electron.app && !electron.app.isReady() ? new Promise(resolve => electron.app.once('ready', resolve)) : Promise.resolve();\n/**\n * Fetch function\n *\n * @param {string|Request} url Absolute url or Request instance\n * @param {Object} [opts] Fetch options\n * @return {Promise}\n */\n\nfunction fetch(url, opts = {}) {\n  // wrap http.request into fetch\n  return isReady.then(() => new Promise((resolve$1, reject) => {\n    // build request object\n    const request = new Request(url, opts);\n    const options = getNodeRequestOptions(request);\n    const send = request.useElectronNet ? electron.net.request : (options.protocol === 'https:' ? https : http).request; // http.request only support string as host header, this hack make custom host header possible\n\n    if (options.headers.host) {\n      options.headers.host = options.headers.host[0];\n    }\n    if (request.signal && request.signal.aborted) {\n      reject(new FetchError('request aborted', 'abort'));\n      return;\n    } // send request\n\n    let headers;\n    if (request.useElectronNet) {\n      headers = options.headers;\n      delete options.headers;\n      options.session = opts.session || electron.session.defaultSession;\n      options.useSessionCookies = request.useSessionCookies;\n    } else {\n      if (opts.agent) options.agent = opts.agent;\n      if (opts.onLogin) reject(new Error('\"onLogin\" option is only supported with \"useElectronNet\" enabled'));\n    }\n    const req = send(options);\n    if (request.useElectronNet) {\n      for (const headerName in headers) {\n        if (typeof headers[headerName] === 'string') req.setHeader(headerName, headers[headerName]);else {\n          for (var _iterator = _createForOfIteratorHelperLoose(headers[headerName]), _step; !(_step = _iterator()).done;) {\n            const headerValue = _step.value;\n            req.setHeader(headerName, headerValue);\n          }\n        }\n      }\n    }\n    let reqTimeout;\n    const cancelRequest = () => {\n      if (request.useElectronNet) {\n        req.abort(); // in electron, `req.destroy()` does not send abort to server\n      } else {\n        req.destroy(); // in node.js, `req.abort()` is deprecated\n      }\n    };\n\n    const abortRequest = () => {\n      const err = new FetchError('request aborted', 'abort');\n      reject(err);\n      cancelRequest();\n      req.emit('error', err);\n    };\n    if (request.signal) {\n      request.signal.addEventListener('abort', abortRequest);\n    }\n    if (request.timeout) {\n      reqTimeout = setTimeout(() => {\n        const err = new FetchError(`network timeout at: ${request.url}`, 'request-timeout');\n        reject(err);\n        cancelRequest();\n      }, request.timeout);\n    }\n    if (request.useElectronNet) {\n      // handle authenticating proxies\n      req.on('login', (authInfo, callback) => {\n        if (opts.user && opts.password) {\n          callback(opts.user, opts.password);\n        } else if (opts.onLogin) {\n          opts.onLogin(authInfo).then(credentials => {\n            if (credentials) {\n              callback(credentials.username, credentials.password);\n            } else {\n              callback();\n            }\n          }).catch(error => {\n            cancelRequest();\n            reject(error);\n          });\n        } else {\n          cancelRequest();\n          reject(new FetchError(`login event received from ${authInfo.host} but no credentials or onLogin handler provided`, 'proxy', {\n            code: 'PROXY_AUTH_FAILED'\n          }));\n        }\n      });\n    }\n    req.on('error', err => {\n      clearTimeout(reqTimeout);\n      if (request.signal) {\n        request.signal.removeEventListener('abort', abortRequest);\n      }\n      reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, 'system', err));\n    });\n    req.on('abort', () => {\n      clearTimeout(reqTimeout);\n      if (request.signal) {\n        request.signal.removeEventListener('abort', abortRequest);\n      }\n    });\n    req.on('response', res => {\n      try {\n        clearTimeout(reqTimeout);\n        if (request.signal) {\n          request.signal.removeEventListener('abort', abortRequest);\n        } // handle redirect\n\n        if (fetch.isRedirect(res.statusCode) && request.redirect !== 'manual') {\n          if (request.redirect === 'error') {\n            reject(new FetchError(`redirect mode is set to error: ${request.url}`, 'no-redirect'));\n            return;\n          }\n          if (request.counter >= request.follow) {\n            reject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));\n            return;\n          }\n          if (!res.headers.location) {\n            reject(new FetchError(`redirect location header missing at: ${request.url}`, 'invalid-redirect'));\n            return;\n          } // per fetch spec, for POST request with 301/302 response, or any request with 303 response, use GET when following redirect\n\n          if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {\n            request.method = 'GET';\n            request.body = null;\n            request.headers.delete('content-length');\n          }\n          request.counter++;\n          resolve$1(fetch(resolve(request.url, res.headers.location), request));\n          return;\n        } // normalize location header for manual redirect mode\n\n        const headers = new Headers();\n        for (var _i = 0, _Object$keys = Object.keys(res.headers); _i < _Object$keys.length; _i++) {\n          const name = _Object$keys[_i];\n          if (Array.isArray(res.headers[name])) {\n            for (var _iterator2 = _createForOfIteratorHelperLoose(res.headers[name]), _step2; !(_step2 = _iterator2()).done;) {\n              const val = _step2.value;\n              headers.append(name, val);\n            }\n          } else {\n            headers.append(name, res.headers[name]);\n          }\n        }\n        if (request.redirect === 'manual' && headers.has('location')) {\n          headers.set('location', resolve(request.url, headers.get('location')));\n        } // prepare response\n\n        let body = new PassThrough();\n        res.on('error', err => body.emit('error', err));\n        res.pipe(body);\n        body.on('error', cancelRequest);\n        body.on('cancel-request', cancelRequest);\n        const abortBody = () => {\n          res.destroy();\n          res.emit('error', new FetchError('request aborted', 'abort')); // separated from the `.destroy()` because somehow Node's IncomingMessage streams do not emit errors on destroy\n        };\n\n        if (request.signal) {\n          request.signal.addEventListener('abort', abortBody);\n          res.on('end', () => {\n            request.signal.removeEventListener('abort', abortBody);\n          });\n          res.on('error', () => {\n            request.signal.removeEventListener('abort', abortBody);\n          });\n        }\n        const responseOptions = {\n          url: request.url,\n          status: res.statusCode,\n          statusText: res.statusMessage,\n          headers,\n          size: request.size,\n          timeout: request.timeout,\n          useElectronNet: request.useElectronNet,\n          useSessionCookies: request.useSessionCookies\n        }; // HTTP-network fetch step 16.1.2\n\n        const codings = headers.get('Content-Encoding'); // HTTP-network fetch step 16.1.3: handle content codings\n        // in following scenarios we ignore compression support\n        // 1. running on Electron/net module (it manages it for us)\n        // 2. HEAD request\n        // 3. no Content-Encoding header\n        // 4. no content response (204)\n        // 5. content not modified response (304)\n\n        if (!request.useElectronNet && request.method !== 'HEAD' && codings !== null && res.statusCode !== 204 && res.statusCode !== 304) {\n          // Be less strict when decoding compressed responses, since sometimes\n          // servers send slightly invalid responses that are still accepted\n          // by common browsers.\n          // Always using Z_SYNC_FLUSH is what cURL does.\n          // /!\\ This is disabled for now, because it seems broken in recent node\n          // const zlibOptions = {\n          //   flush: zlib.Z_SYNC_FLUSH,\n          //   finishFlush: zlib.Z_SYNC_FLUSH\n          // }\n          if (codings === 'gzip' || codings === 'x-gzip') {\n            // for gzip\n            body = body.pipe(zlib.createGunzip());\n          } else if (codings === 'deflate' || codings === 'x-deflate') {\n            // for deflate\n            // handle the infamous raw deflate response from old servers\n            // a hack for old IIS and Apache servers\n            const raw = res.pipe(new PassThrough());\n            return raw.once('data', chunk => {\n              // see http://stackoverflow.com/questions/37519828\n              if ((chunk[0] & 0x0F) === 0x08) {\n                body = body.pipe(zlib.createInflate());\n              } else {\n                body = body.pipe(zlib.createInflateRaw());\n              }\n              const response = new Response(body, responseOptions);\n              resolve$1(response);\n            });\n          }\n        }\n        const response = new Response(body, responseOptions);\n        resolve$1(response);\n      } catch (error) {\n        reject(new FetchError(`Invalid response: ${error.message}`, 'invalid-response'));\n        cancelRequest();\n      }\n    });\n    writeToStream(req, request);\n  }));\n}\n/**\n * Redirect code matching\n *\n * @param {number} code Status code\n * @return {boolean}\n */\n\nfetch.isRedirect = code => code === 301 || code === 302 || code === 303 || code === 307 || code === 308;\nexport { FetchError, Headers, Request, Response, fetch as default };","map":{"version":3,"names":["parse","format","resolve","http","STATUS_CODES","https","zlib","Stream","PassThrough","convert","_unsupportedIterableToArray","o","minLen","_arrayLikeToArray","n","Object","prototype","toString","call","slice","constructor","name","Array","from","test","arr","len","length","i","arr2","_createForOfIteratorHelperLoose","allowArrayLike","it","Symbol","iterator","next","bind","isArray","done","value","TypeError","BUFFER","TYPE","CLOSED","Blob","defineProperty","toStringTag","writable","enumerable","configurable","blobParts","arguments","options","buffers","a","Number","element","buffer","Buffer","ArrayBuffer","isView","Uint8Array","byteOffset","byteLength","String","push","concat","type","undefined","toLowerCase","size","isClosed","start","end","relativeStart","relativeEnd","Math","max","min","span","slicedBuffer","blob","close","netErrorMap","ERR_CONNECTION_REFUSED","ERR_EMPTY_RESPONSE","ERR_NAME_NOT_RESOLVED","ERR_CONTENT_DECODING_FAILED","ERR_CONTENT_DECODING_INIT_FAILED","FetchError","message","systemError","Error","regex","errorCode","exec","hasOwnProperty","code","errno","captureStackTrace","create","DISTURBED","Body","body","timeout","isBuffer","bodyUsed","arrayBuffer","consumeBody","then","buf","ct","headers","get","assign","json","JSON","text","textConverted","convertBody","mixIn","proto","_iterator","getOwnPropertyNames","_step","desc","getOwnPropertyDescriptor","Promise","reject","url","alloc","accum","accumBytes","abort","resTimeout","setTimeout","emit","on","err","chunk","clearTimeout","charset","res","str","pop","clone","instance","p1","p2","getBoundary","pipe","extractContentType","getTotalBytes","getLengthSync","_lengthRetrievers","hasKnownLength","writeToStream","dest","write","useElectronNet","chunkedEncoding","isValidTokenChar","ch","checkIsHttpToken","val","charCodeAt","checkInvalidHeaderChar","c","sanitizeName","sanitizeValue","MAP","Headers","init","method","pairs","pair","_i","_pairs","append","_i2","_Object$keys","keys","key","list","join","forEach","callback","thisArg","getHeaderPairs","_pairs$i","set","has","delete","raw","createHeadersIterator","values","entries","kind","sort","map","k","_iterator2","_step2","_iterator3","_step3","INTERNAL","target","HeadersIteratorPrototype","index","setPrototypeOf","getPrototypeOf","_this$INTERNAL","result","Response","opts","status","statusText","ok","PARSED_URL","Request","input","parsedURL","href","inputBody","toUpperCase","redirect","signal","process","versions","electron","Boolean","useSessionCookies","contentType","follow","counter","session","getNodeRequestOptions","request","protocol","hostname","contentLengthValue","totalBytes","require","isReady","app","once","fetch","resolve$1","send","net","host","aborted","defaultSession","agent","onLogin","req","headerName","setHeader","headerValue","reqTimeout","cancelRequest","destroy","abortRequest","addEventListener","authInfo","user","password","credentials","username","catch","error","removeEventListener","isRedirect","statusCode","location","abortBody","responseOptions","statusMessage","codings","createGunzip","createInflate","createInflateRaw","response","default"],"sources":["C:/Users/Levi/Documents/szakdoga/vizsgaremek/node_modules/electron-fetch/lib/index.es.js"],"sourcesContent":["import { parse, format, resolve } from 'url';\nimport * as http from 'http';\nimport { STATUS_CODES } from 'http';\nimport * as https from 'https';\nimport * as zlib from 'zlib';\nimport Stream, { PassThrough } from 'stream';\nimport { convert } from 'encoding';\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\n// Based on https://github.com/tmpvar/jsdom/blob/aa85b2abf07766ff7bf5c1f6daafb3726f2f2db5/lib/jsdom/living/blob.js\n// (MIT licensed)\nconst BUFFER = Symbol('buffer');\nconst TYPE = Symbol('type');\nconst CLOSED = Symbol('closed');\nclass Blob {\n  constructor() {\n    Object.defineProperty(this, Symbol.toStringTag, {\n      value: 'Blob',\n      writable: false,\n      enumerable: false,\n      configurable: true\n    });\n    this[CLOSED] = false;\n    this[TYPE] = '';\n    const blobParts = arguments[0];\n    const options = arguments[1];\n    const buffers = [];\n\n    if (blobParts) {\n      const a = blobParts;\n      const length = Number(a.length);\n\n      for (let i = 0; i < length; i++) {\n        const element = a[i];\n        let buffer;\n\n        if (element instanceof Buffer) {\n          buffer = element;\n        } else if (ArrayBuffer.isView(element)) {\n          buffer = Buffer.from(new Uint8Array(element.buffer, element.byteOffset, element.byteLength));\n        } else if (element instanceof ArrayBuffer) {\n          buffer = Buffer.from(new Uint8Array(element));\n        } else if (element instanceof Blob) {\n          buffer = element[BUFFER];\n        } else {\n          buffer = Buffer.from(typeof element === 'string' ? element : String(element));\n        }\n\n        buffers.push(buffer);\n      }\n    }\n\n    this[BUFFER] = Buffer.concat(buffers);\n    const type = options && options.type !== undefined && String(options.type).toLowerCase();\n\n    if (type && !/[^\\u0020-\\u007E]/.test(type)) {\n      this[TYPE] = type;\n    }\n  }\n\n  get size() {\n    return this[CLOSED] ? 0 : this[BUFFER].length;\n  }\n\n  get type() {\n    return this[TYPE];\n  }\n\n  get isClosed() {\n    return this[CLOSED];\n  }\n\n  slice() {\n    const size = this.size;\n    const start = arguments[0];\n    const end = arguments[1];\n    let relativeStart, relativeEnd;\n\n    if (start === undefined) {\n      relativeStart = 0;\n    } else if (start < 0) {\n      relativeStart = Math.max(size + start, 0);\n    } else {\n      relativeStart = Math.min(start, size);\n    }\n\n    if (end === undefined) {\n      relativeEnd = size;\n    } else if (end < 0) {\n      relativeEnd = Math.max(size + end, 0);\n    } else {\n      relativeEnd = Math.min(end, size);\n    }\n\n    const span = Math.max(relativeEnd - relativeStart, 0);\n    const buffer = this[BUFFER];\n    const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);\n    const blob = new Blob([], {\n      type: arguments[2]\n    });\n    blob[BUFFER] = slicedBuffer;\n    blob[CLOSED] = this[CLOSED];\n    return blob;\n  }\n\n  close() {\n    this[CLOSED] = true;\n  }\n\n}\nObject.defineProperty(Blob.prototype, Symbol.toStringTag, {\n  value: 'BlobPrototype',\n  writable: false,\n  enumerable: false,\n  configurable: true\n});\n\n/**\n * fetch-error.js\n *\n * FetchError interface for operational errors\n */\n\n/**\n * Create FetchError instance\n *\n * @param {string} message Error message for human\n * @param {string} type Error type for machine\n * @param {string} systemError For Node.js system error\n * @return {FetchError}\n */\nconst netErrorMap = {\n  ERR_CONNECTION_REFUSED: 'ECONNREFUSED',\n  ERR_EMPTY_RESPONSE: 'ECONNRESET',\n  ERR_NAME_NOT_RESOLVED: 'ENOTFOUND',\n  ERR_CONTENT_DECODING_FAILED: 'Z_DATA_ERROR',\n  ERR_CONTENT_DECODING_INIT_FAILED: 'Z_DATA_ERROR'\n};\nfunction FetchError(message, type, systemError) {\n  Error.call(this, message);\n  const regex = /^.*net::(.*)/;\n\n  if (regex.test(message)) {\n    let errorCode = regex.exec(message)[1]; // istanbul ignore else\n\n    if (Object.prototype.hasOwnProperty.call(netErrorMap, errorCode)) errorCode = netErrorMap[errorCode];\n    systemError = {\n      code: errorCode\n    };\n  }\n\n  this.message = message;\n  this.type = type; // when err.type is `system`, err.code contains system error code\n\n  if (systemError) {\n    this.code = this.errno = systemError.code;\n  } // hide custom error implementation details from end-users\n\n\n  Error.captureStackTrace(this, this.constructor);\n}\nFetchError.prototype = Object.create(Error.prototype);\nFetchError.prototype.constructor = FetchError;\nFetchError.prototype.name = 'FetchError';\n\nconst DISTURBED = Symbol('disturbed');\n/**\n * Body class\n *\n * Cannot use ES6 class because Body must be called with .call().\n *\n * @param {Stream|string|Blob|Buffer|null} body Readable stream\n * @param {number} size\n * @param {number} timeout\n */\n\nfunction Body(body, {\n  size = 0,\n  timeout = 0\n} = {}) {\n  if (body == null) {\n    // body is undefined or null\n    body = null;\n  } else if (typeof body === 'string') ; else if (body instanceof Blob) ; else if (Buffer.isBuffer(body)) ; else if (body instanceof Stream) ; else {\n    // none of the above\n    // coerce to string\n    body = String(body);\n  }\n\n  this.body = body;\n  this[DISTURBED] = false;\n  this.size = size;\n  this.timeout = timeout;\n}\nBody.prototype = {\n  get bodyUsed() {\n    return this[DISTURBED];\n  },\n\n  /**\n   * Decode response as ArrayBuffer\n   *\n   * @return {Promise}\n   */\n  arrayBuffer() {\n    return consumeBody.call(this).then(buf => buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength));\n  },\n\n  /**\n   * Return raw response as Blob\n   *\n   * @return {Promise}\n   */\n  blob() {\n    const ct = this.headers && this.headers.get('content-type') || '';\n    return consumeBody.call(this).then(buf => Object.assign( // Prevent copying\n    new Blob([], {\n      type: ct.toLowerCase()\n    }), {\n      [BUFFER]: buf\n    }));\n  },\n\n  /**\n   * Decode response as json\n   *\n   * @return {Promise}\n   */\n  json() {\n    return consumeBody.call(this).then(buffer => JSON.parse(buffer.toString()));\n  },\n\n  /**\n   * Decode response as text\n   *\n   * @return {Promise}\n   */\n  text() {\n    return consumeBody.call(this).then(buffer => buffer.toString());\n  },\n\n  /**\n   * Decode response as buffer (non-spec api)\n   *\n   * @return {Promise}\n   */\n  buffer() {\n    return consumeBody.call(this);\n  },\n\n  /**\n   * Decode response as text, while automatically detecting the encoding and\n   * trying to decode to UTF-8 (non-spec api)\n   *\n   * @return {Promise}\n   */\n  textConverted() {\n    return consumeBody.call(this).then(buffer => convertBody(buffer, this.headers));\n  }\n\n};\n\nBody.mixIn = function (proto) {\n  for (var _iterator = _createForOfIteratorHelperLoose(Object.getOwnPropertyNames(Body.prototype)), _step; !(_step = _iterator()).done;) {\n    const name = _step.value;\n\n    // istanbul ignore else\n    if (!(name in proto)) {\n      const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);\n      Object.defineProperty(proto, name, desc);\n    }\n  }\n};\n/**\n * Decode buffers into utf-8 string\n *\n * @return {Promise}\n */\n\n\nfunction consumeBody() {\n  if (this[DISTURBED]) {\n    return Promise.reject(new Error(`body used already for: ${this.url}`));\n  }\n\n  this[DISTURBED] = true; // body is null\n\n  if (this.body === null) {\n    return Promise.resolve(Buffer.alloc(0));\n  } // body is string\n\n\n  if (typeof this.body === 'string') {\n    return Promise.resolve(Buffer.from(this.body));\n  } // body is blob\n\n\n  if (this.body instanceof Blob) {\n    return Promise.resolve(this.body[BUFFER]);\n  } // body is buffer\n\n\n  if (Buffer.isBuffer(this.body)) {\n    return Promise.resolve(this.body);\n  } // istanbul ignore if: should never happen\n\n\n  if (!(this.body instanceof Stream)) {\n    return Promise.resolve(Buffer.alloc(0));\n  } // body is stream\n  // get ready to actually consume the body\n\n\n  const accum = [];\n  let accumBytes = 0;\n  let abort = false;\n  return new Promise((resolve, reject) => {\n    let resTimeout; // allow timeout on slow response body\n\n    if (this.timeout) {\n      resTimeout = setTimeout(() => {\n        abort = true;\n        reject(new FetchError(`Response timeout while trying to fetch ${this.url} (over ${this.timeout}ms)`, 'body-timeout'));\n        this.body.emit('cancel-request');\n      }, this.timeout);\n    } // handle stream error, such as incorrect content-encoding\n\n\n    this.body.on('error', err => {\n      reject(new FetchError(`Invalid response body while trying to fetch ${this.url}: ${err.message}`, 'system', err));\n    });\n    this.body.on('data', chunk => {\n      if (abort || chunk === null) {\n        return;\n      }\n\n      if (this.size && accumBytes + chunk.length > this.size) {\n        abort = true;\n        reject(new FetchError(`content size at ${this.url} over limit: ${this.size}`, 'max-size'));\n        this.body.emit('cancel-request');\n        return;\n      }\n\n      accumBytes += chunk.length;\n      accum.push(chunk);\n    });\n    this.body.on('end', () => {\n      if (abort) {\n        return;\n      }\n\n      clearTimeout(resTimeout);\n      resolve(Buffer.concat(accum));\n    });\n  });\n}\n/**\n * Detect buffer encoding and convert to target encoding\n * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding\n *\n * @param {Buffer} buffer   Incoming buffer\n * @param {Headers} headers\n * @return {string}\n */\n\n\nfunction convertBody(buffer, headers) {\n  const ct = headers.get('content-type');\n  let charset = 'utf-8';\n  let res; // header\n\n  if (ct) {\n    res = /charset=([^;]*)/i.exec(ct);\n  } // no charset in content type, peek at response body for at most 1024 bytes\n\n\n  const str = buffer.slice(0, 1024).toString(); // html5\n\n  if (!res && str) {\n    res = /<meta.+?charset=(['\"])(.+?)\\1/i.exec(str);\n  } // html4\n\n\n  if (!res && str) {\n    res = /<meta[\\s]+?http-equiv=(['\"])content-type\\1[\\s]+?content=(['\"])(.+?)\\2/i.exec(str);\n\n    if (res) {\n      res = /charset=(.*)/i.exec(res.pop());\n    }\n  } // xml\n\n\n  if (!res && str) {\n    res = /<\\?xml.+?encoding=(['\"])(.+?)\\1/i.exec(str);\n  } // found charset\n\n\n  if (res) {\n    charset = res.pop(); // prevent decode issues when sites use incorrect encoding\n    // ref: https://hsivonen.fi/encoding-menu/\n\n    if (charset === 'gb2312' || charset === 'gbk') {\n      charset = 'gb18030';\n    }\n  } // turn raw buffers into a single utf-8 buffer\n\n\n  return convert(buffer, 'UTF-8', charset).toString();\n}\n/**\n * Clone body given Res/Req instance\n *\n * @param {Response|Request} instance Response or Request instance\n * @return {string|Blob|Buffer|Stream}\n */\n\n\nfunction clone(instance) {\n  let p1, p2;\n  let body = instance.body; // don't allow cloning a used body\n\n  if (instance.bodyUsed) {\n    throw new Error('cannot clone body after it is used');\n  } // check that body is a stream and not form-data object\n  // note: we can't clone the form-data object without having it as a dependency\n\n\n  if (body instanceof Stream && typeof body.getBoundary !== 'function') {\n    // tee instance body\n    p1 = new PassThrough();\n    p2 = new PassThrough();\n    body.pipe(p1);\n    body.pipe(p2); // set instance body to teed body and return the other teed body\n\n    instance.body = p1;\n    body = p2;\n  }\n\n  return body;\n}\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present and non-null.\n *\n * @param {Response|Request} instance Response or Request instance\n */\n\nfunction extractContentType(instance) {\n  const body = instance.body; // istanbul ignore if: Currently, because of a guard in Request, body\n  // can never be null. Included here for completeness.\n\n  if (body === null) {\n    // body is null\n    return null;\n  } else if (typeof body === 'string') {\n    // body is string\n    return 'text/plain;charset=UTF-8';\n  } else if (body instanceof Blob) {\n    // body is blob\n    return body.type || null;\n  } else if (Buffer.isBuffer(body)) {\n    // body is buffer\n    return null;\n  } else if (typeof body.getBoundary === 'function') {\n    // detect form data input from form-data module\n    return `multipart/form-data;boundary=${body.getBoundary()}`;\n  } else {\n    // body is stream\n    // can't really do much about this\n    return null;\n  }\n}\nfunction getTotalBytes(instance) {\n  const body = instance.body; // istanbul ignore if: included for completion\n\n  if (body === null) {\n    // body is null\n    return 0;\n  } else if (typeof body === 'string') {\n    // body is string\n    return Buffer.byteLength(body);\n  } else if (body instanceof Blob) {\n    // body is blob\n    return body.size;\n  } else if (Buffer.isBuffer(body)) {\n    // body is buffer\n    return body.length;\n  } else if (body && typeof body.getLengthSync === 'function') {\n    // detect form data input from form-data module\n    // istanbul ignore next\n    if (body._lengthRetrievers && body._lengthRetrievers.length === 0 || // 1.x\n    body.hasKnownLength && body.hasKnownLength()) {\n      // 2.x\n      return body.getLengthSync();\n    }\n\n    return null;\n  } else {\n    // body is stream\n    // can't really do much about this\n    return null;\n  }\n}\nfunction writeToStream(dest, instance) {\n  const body = instance.body;\n\n  if (body === null) {\n    // body is null\n    dest.end();\n  } else if (typeof body === 'string') {\n    // body is string\n    dest.write(body);\n    dest.end();\n  } else if (body instanceof Blob) {\n    // body is blob\n    dest.write(body[BUFFER]);\n    dest.end();\n  } else if (Buffer.isBuffer(body)) {\n    // body is buffer\n    dest.write(body);\n    dest.end();\n  } else {\n    // body is stream\n    if (instance.useElectronNet) {\n      dest.chunkedEncoding = instance.chunkedEncoding; // Force a first write to start the request otherwise an empty body stream\n      // will cause an error when closing the dest stream with Electron v7.\n\n      dest.write('');\n    }\n\n    body.pipe(new PassThrough()) // I have to put a PassThrough because somehow, FormData streams are not eaten by electron/net\n    .pipe(dest);\n  }\n}\n\n/**\n * A set of utilities borrowed from Node.js' _http_common.js\n */\n\n/**\n * Verifies that the given val is a valid HTTP token\n * per the rules defined in RFC 7230\n * See https://tools.ietf.org/html/rfc7230#section-3.2.6\n *\n * Allowed characters in an HTTP token:\n * ^_`a-z  94-122\n * A-Z     65-90\n * -       45\n * 0-9     48-57\n * !       33\n * #$%&'   35-39\n * *+      42-43\n * .       46\n * |       124\n * ~       126\n *\n * This implementation of checkIsHttpToken() loops over the string instead of\n * using a regular expression since the former is up to 180% faster with v8 4.9\n * depending on the string length (the shorter the string, the larger the\n * performance difference)\n *\n * Additionally, checkIsHttpToken() is currently designed to be inlinable by v8,\n * so take care when making changes to the implementation so that the source\n * code size does not exceed v8's default max_inlined_source_size setting.\n **/\n// istanbul ignore next\nfunction isValidTokenChar(ch) {\n  if (ch >= 94 && ch <= 122) {\n    return true;\n  }\n\n  if (ch >= 65 && ch <= 90) {\n    return true;\n  }\n\n  if (ch === 45) {\n    return true;\n  }\n\n  if (ch >= 48 && ch <= 57) {\n    return true;\n  }\n\n  if (ch === 34 || ch === 40 || ch === 41 || ch === 44) {\n    return false;\n  }\n\n  if (ch >= 33 && ch <= 46) {\n    return true;\n  }\n\n  if (ch === 124 || ch === 126) {\n    return true;\n  }\n\n  return false;\n} // istanbul ignore next\n\n\nfunction checkIsHttpToken(val) {\n  if (typeof val !== 'string' || val.length === 0) {\n    return false;\n  }\n\n  if (!isValidTokenChar(val.charCodeAt(0))) {\n    return false;\n  }\n\n  const len = val.length;\n\n  if (len > 1) {\n    if (!isValidTokenChar(val.charCodeAt(1))) {\n      return false;\n    }\n\n    if (len > 2) {\n      if (!isValidTokenChar(val.charCodeAt(2))) {\n        return false;\n      }\n\n      if (len > 3) {\n        if (!isValidTokenChar(val.charCodeAt(3))) {\n          return false;\n        }\n\n        for (let i = 4; i < len; i++) {\n          if (!isValidTokenChar(val.charCodeAt(i))) {\n            return false;\n          }\n        }\n      }\n    }\n  }\n\n  return true;\n}\n/**\n * True if val contains an invalid field-vchar\n *  field-value    = *( field-content / obs-fold )\n *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n *  field-vchar    = VCHAR / obs-text\n *\n * checkInvalidHeaderChar() is currently designed to be inlinable by v8,\n * so take care when making changes to the implementation so that the source\n * code size does not exceed v8's default max_inlined_source_size setting.\n **/\n// istanbul ignore next\n\nfunction checkInvalidHeaderChar(val) {\n  val += '';\n\n  if (val.length < 1) {\n    return false;\n  }\n\n  let c = val.charCodeAt(0);\n\n  if (c <= 31 && c !== 9 || c > 255 || c === 127) {\n    return true;\n  }\n\n  if (val.length < 2) {\n    return false;\n  }\n\n  c = val.charCodeAt(1);\n\n  if (c <= 31 && c !== 9 || c > 255 || c === 127) {\n    return true;\n  }\n\n  if (val.length < 3) {\n    return false;\n  }\n\n  c = val.charCodeAt(2);\n\n  if (c <= 31 && c !== 9 || c > 255 || c === 127) {\n    return true;\n  }\n\n  for (let i = 3; i < val.length; ++i) {\n    c = val.charCodeAt(i);\n\n    if (c <= 31 && c !== 9 || c > 255 || c === 127) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction sanitizeName(name) {\n  name += '';\n\n  if (!checkIsHttpToken(name)) {\n    throw new TypeError(`${name} is not a legal HTTP header name`);\n  }\n\n  return name.toLowerCase();\n}\n\nfunction sanitizeValue(value) {\n  value += '';\n\n  if (checkInvalidHeaderChar(value)) {\n    throw new TypeError(`${value} is not a legal HTTP header value`);\n  }\n\n  return value;\n}\n\nconst MAP = Symbol('map');\nclass Headers {\n  /**\n   * Headers class\n   *\n   * @param {Object} init Response headers\n   */\n  constructor(init = undefined) {\n    this[MAP] = Object.create(null); // We don't worry about converting prop to ByteString here as append()\n    // will handle it.\n\n    if (init == null) ; else if (typeof init === 'object') {\n      const method = init[Symbol.iterator];\n\n      if (method != null) {\n        if (typeof method !== 'function') {\n          throw new TypeError('Header pairs must be iterable');\n        } // sequence<sequence<ByteString>>\n        // Note: per spec we have to first exhaust the lists then process them\n\n\n        const pairs = [];\n\n        for (var _iterator = _createForOfIteratorHelperLoose(init), _step; !(_step = _iterator()).done;) {\n          const pair = _step.value;\n\n          if (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') {\n            throw new TypeError('Each header pair must be iterable');\n          }\n\n          pairs.push(Array.from(pair));\n        }\n\n        for (var _i = 0, _pairs = pairs; _i < _pairs.length; _i++) {\n          const pair = _pairs[_i];\n\n          if (pair.length !== 2) {\n            throw new TypeError('Each header pair must be a name/value tuple');\n          }\n\n          this.append(pair[0], pair[1]);\n        }\n      } else {\n        // record<ByteString, ByteString>\n        for (var _i2 = 0, _Object$keys = Object.keys(init); _i2 < _Object$keys.length; _i2++) {\n          const key = _Object$keys[_i2];\n          const value = init[key];\n          this.append(key, value);\n        }\n      }\n    } else {\n      throw new TypeError('Provided initializer must be an object');\n    }\n\n    Object.defineProperty(this, Symbol.toStringTag, {\n      value: 'Headers',\n      writable: false,\n      enumerable: false,\n      configurable: true\n    });\n  }\n  /**\n   * Return first header value given name\n   *\n   * @param {string} name Header name\n   * @return {string}\n   */\n\n\n  get(name) {\n    const list = this[MAP][sanitizeName(name)];\n\n    if (!list) {\n      return null;\n    }\n\n    return list.join(',');\n  }\n  /**\n   * Iterate over all headers\n   *\n   * @param {function} callback Executed for each item with parameters (value, name, thisArg)\n   * @param {boolean} thisArg `this` context for callback function\n   */\n\n\n  forEach(callback, thisArg = undefined) {\n    let pairs = getHeaderPairs(this);\n    let i = 0;\n\n    while (i < pairs.length) {\n      const _pairs$i = pairs[i],\n            name = _pairs$i[0],\n            value = _pairs$i[1];\n      callback.call(thisArg, value, name, this);\n      pairs = getHeaderPairs(this);\n      i++;\n    }\n  }\n  /**\n   * Overwrite header values given name\n   *\n   * @param {string} name Header name\n   * @param {string|Array.<string|*>|*} value Header value\n   */\n\n\n  set(name, value) {\n    this[MAP][sanitizeName(name)] = [sanitizeValue(value)];\n  }\n  /**\n   * Append a value onto existing header\n   *\n   * @param {string} name Header name\n   * @param {string|Array.<string|*>|*} value Header value\n   */\n\n\n  append(name, value) {\n    if (!this.has(name)) {\n      this.set(name, value);\n      return;\n    }\n\n    this[MAP][sanitizeName(name)].push(sanitizeValue(value));\n  }\n  /**\n   * Check for header name existence\n   *\n   * @param {string} name Header name\n   * @return {boolean}\n   */\n\n\n  has(name) {\n    return !!this[MAP][sanitizeName(name)];\n  }\n  /**\n   * Delete all header values given name\n   *\n   * @param {string} name Header name\n   */\n\n\n  delete(name) {\n    delete this[MAP][sanitizeName(name)];\n  }\n  /**\n   * Return raw headers (non-spec api)\n   *\n   * @return {Object}\n   */\n\n\n  raw() {\n    return this[MAP];\n  }\n  /**\n   * Get an iterator on keys.\n   *\n   * @return {Iterator}\n   */\n\n\n  keys() {\n    return createHeadersIterator(this, 'key');\n  }\n  /**\n   * Get an iterator on values.\n   *\n   * @return {Iterator}\n   */\n\n\n  values() {\n    return createHeadersIterator(this, 'value');\n  }\n  /**\n   * Get an iterator on entries.\n   *\n   * This is the default iterator of the Headers object.\n   *\n   * @return {Iterator}\n   */\n\n\n  [Symbol.iterator]() {\n    return createHeadersIterator(this, 'key+value');\n  }\n\n}\nHeaders.prototype.entries = Headers.prototype[Symbol.iterator];\nObject.defineProperty(Headers.prototype, Symbol.toStringTag, {\n  value: 'HeadersPrototype',\n  writable: false,\n  enumerable: false,\n  configurable: true\n});\n\nfunction getHeaderPairs(headers, kind) {\n  if (kind === 'key') return Object.keys(headers[MAP]).sort().map(k => [k]);\n  const pairs = [];\n\n  for (var _iterator2 = _createForOfIteratorHelperLoose(Object.keys(headers[MAP]).sort()), _step2; !(_step2 = _iterator2()).done;) {\n    const key = _step2.value;\n\n    for (var _iterator3 = _createForOfIteratorHelperLoose(headers[MAP][key]), _step3; !(_step3 = _iterator3()).done;) {\n      const value = _step3.value;\n      pairs.push([key, value]);\n    }\n  }\n\n  return pairs;\n}\n\nconst INTERNAL = Symbol('internal');\n\nfunction createHeadersIterator(target, kind) {\n  const iterator = Object.create(HeadersIteratorPrototype);\n  iterator[INTERNAL] = {\n    target,\n    kind,\n    index: 0\n  };\n  return iterator;\n}\n\nconst HeadersIteratorPrototype = Object.setPrototypeOf({\n  next() {\n    // istanbul ignore if\n    if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {\n      throw new TypeError('Value of `this` is not a HeadersIterator');\n    }\n\n    const _this$INTERNAL = this[INTERNAL],\n          target = _this$INTERNAL.target,\n          kind = _this$INTERNAL.kind,\n          index = _this$INTERNAL.index;\n    const values = getHeaderPairs(target, kind);\n    const len = values.length;\n\n    if (index >= len) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n\n    const pair = values[index];\n    this[INTERNAL].index = index + 1;\n    let result;\n\n    if (kind === 'key') {\n      result = pair[0];\n    } else if (kind === 'value') {\n      result = pair[1];\n    } else {\n      result = pair;\n    }\n\n    return {\n      value: result,\n      done: false\n    };\n  }\n\n}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));\nObject.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {\n  value: 'HeadersIterator',\n  writable: false,\n  enumerable: false,\n  configurable: true\n});\n\n/**\n * response.js\n *\n * Response class provides content decoding\n */\n/**\n * Response class\n *\n * @param {Stream} body Readable stream\n * @param {Object} opts Response options\n */\n\nclass Response {\n  constructor(body = null, opts = {}) {\n    Body.call(this, body, opts);\n    this.url = opts.url;\n    this.status = opts.status || 200;\n    this.statusText = opts.statusText || STATUS_CODES[this.status];\n    this.headers = new Headers(opts.headers);\n    this.useElectronNet = opts.useElectronNet;\n    Object.defineProperty(this, Symbol.toStringTag, {\n      value: 'Response',\n      writable: false,\n      enumerable: false,\n      configurable: true\n    });\n  }\n  /**\n   * Convenience property representing if the request ended normally\n   */\n\n\n  get ok() {\n    return this.status >= 200 && this.status < 300;\n  }\n  /**\n   * Clone this response\n   *\n   * @return {Response}\n   */\n\n\n  clone() {\n    return new Response(clone(this), {\n      url: this.url,\n      status: this.status,\n      statusText: this.statusText,\n      headers: this.headers,\n      ok: this.ok,\n      useElectronNet: this.useElectronNet\n    });\n  }\n\n}\nBody.mixIn(Response.prototype);\nObject.defineProperty(Response.prototype, Symbol.toStringTag, {\n  value: 'ResponsePrototype',\n  writable: false,\n  enumerable: false,\n  configurable: true\n});\n\n/**\n * request.js\n *\n * Request class contains server only options\n */\nconst PARSED_URL = Symbol('url');\n/**\n * Request class\n *\n * @param {string|Request} input Url or Request instance\n * @param {Object} init Custom options\n */\n\nclass Request {\n  constructor(input, init = {}) {\n    let parsedURL; // normalize input\n\n    if (!(input instanceof Request)) {\n      if (input && input.href) {\n        // in order to support Node.js' Url objects; though WHATWG's URL objects\n        // will fall into this branch also (since their `toString()` will return\n        // `href` property anyway)\n        parsedURL = parse(input.href);\n      } else {\n        // coerce input to a string before attempting to parse\n        parsedURL = parse(`${input}`);\n      }\n\n      input = {};\n    } else {\n      parsedURL = parse(input.url);\n    }\n\n    const method = init.method || input.method || 'GET';\n\n    if ((init.body != null || input instanceof Request && input.body !== null) && (method === 'GET' || method === 'HEAD')) {\n      throw new TypeError('Request with GET/HEAD method cannot have body');\n    }\n\n    const inputBody = init.body != null ? init.body : input instanceof Request && input.body !== null ? clone(input) : null;\n    Body.call(this, inputBody, {\n      timeout: init.timeout || input.timeout || 0,\n      size: init.size || input.size || 0\n    }); // fetch spec options\n\n    this.method = method.toUpperCase();\n    this.redirect = init.redirect || input.redirect || 'follow';\n    this.signal = init.signal || input.signal || null;\n    this.headers = new Headers(init.headers || input.headers || {});\n    this.headers.delete('Content-Length'); // user cannot set content-length themself as per fetch spec\n\n    this.chunkedEncoding = false;\n    this.useElectronNet = init.useElectronNet !== undefined // have to do this instead of || because it can be set to false\n    ? init.useElectronNet : input.useElectronNet; // istanbul ignore if\n\n    if (this.useElectronNet && !process.versions.electron) throw new Error('Cannot use Electron/net module on Node.js!');\n\n    if (this.useElectronNet === undefined) {\n      this.useElectronNet = Boolean(process.versions.electron);\n    }\n\n    if (this.useElectronNet) {\n      this.useSessionCookies = init.useSessionCookies !== undefined ? init.useSessionCookies : input.useSessionCookies;\n    }\n\n    if (init.body != null) {\n      const contentType = extractContentType(this);\n\n      if (contentType !== null && !this.headers.has('Content-Type')) {\n        this.headers.append('Content-Type', contentType);\n      }\n    } // server only options\n\n\n    this.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;\n    this.counter = init.counter || input.counter || 0;\n    this.session = init.session || input.session;\n    this[PARSED_URL] = parsedURL;\n    Object.defineProperty(this, Symbol.toStringTag, {\n      value: 'Request',\n      writable: false,\n      enumerable: false,\n      configurable: true\n    });\n  }\n\n  get url() {\n    return format(this[PARSED_URL]);\n  }\n  /**\n   * Clone this request\n   *\n   * @return {Request}\n   */\n\n\n  clone() {\n    return new Request(this);\n  }\n\n}\nBody.mixIn(Request.prototype);\nObject.defineProperty(Request.prototype, Symbol.toStringTag, {\n  value: 'RequestPrototype',\n  writable: false,\n  enumerable: false,\n  configurable: true\n});\nfunction getNodeRequestOptions(request) {\n  const parsedURL = request[PARSED_URL];\n  const headers = new Headers(request.headers); // fetch step 3\n\n  if (!headers.has('Accept')) {\n    headers.set('Accept', '*/*');\n  } // Basic fetch\n\n\n  if (!parsedURL.protocol || !parsedURL.hostname) {\n    throw new TypeError('Only absolute URLs are supported');\n  }\n\n  if (!/^https?:$/.test(parsedURL.protocol)) {\n    throw new TypeError('Only HTTP(S) protocols are supported');\n  } // HTTP-network-or-cache fetch steps 5-9\n\n\n  let contentLengthValue = null;\n\n  if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {\n    contentLengthValue = '0';\n  }\n\n  if (request.body != null) {\n    const totalBytes = getTotalBytes(request);\n\n    if (typeof totalBytes === 'number') {\n      contentLengthValue = String(totalBytes);\n    }\n  }\n\n  if (contentLengthValue) {\n    if (!request.useElectronNet) headers.set('Content-Length', contentLengthValue);\n  } else {\n    request.chunkedEncoding = true;\n  } // HTTP-network-or-cache fetch step 12\n\n\n  if (!headers.has('User-Agent')) {\n    headers.set('User-Agent', `electron-fetch/1.0 ${request.useElectronNet ? 'electron' : 'node'} (+https://github.com/arantes555/electron-fetch)`);\n  } // HTTP-network-or-cache fetch step 16\n\n\n  headers.set('Accept-Encoding', 'gzip,deflate');\n\n  if (!headers.has('Connection')) {\n    headers.set('Connection', 'close');\n  } // HTTP-network fetch step 4\n  // chunked encoding is handled by Node.js when not running in electron\n\n\n  return Object.assign({}, parsedURL, {\n    method: request.method,\n    headers: headers.raw()\n  });\n}\n\nlet electron; // istanbul ignore else\n\nif (process.versions.electron) {\n  electron = require('electron');\n}\n\nconst isReady = electron && electron.app && !electron.app.isReady() ? new Promise(resolve => electron.app.once('ready', resolve)) : Promise.resolve();\n/**\n * Fetch function\n *\n * @param {string|Request} url Absolute url or Request instance\n * @param {Object} [opts] Fetch options\n * @return {Promise}\n */\n\nfunction fetch(url, opts = {}) {\n  // wrap http.request into fetch\n  return isReady.then(() => new Promise((resolve$1, reject) => {\n    // build request object\n    const request = new Request(url, opts);\n    const options = getNodeRequestOptions(request);\n    const send = request.useElectronNet ? electron.net.request : (options.protocol === 'https:' ? https : http).request; // http.request only support string as host header, this hack make custom host header possible\n\n    if (options.headers.host) {\n      options.headers.host = options.headers.host[0];\n    }\n\n    if (request.signal && request.signal.aborted) {\n      reject(new FetchError('request aborted', 'abort'));\n      return;\n    } // send request\n\n\n    let headers;\n\n    if (request.useElectronNet) {\n      headers = options.headers;\n      delete options.headers;\n      options.session = opts.session || electron.session.defaultSession;\n      options.useSessionCookies = request.useSessionCookies;\n    } else {\n      if (opts.agent) options.agent = opts.agent;\n      if (opts.onLogin) reject(new Error('\"onLogin\" option is only supported with \"useElectronNet\" enabled'));\n    }\n\n    const req = send(options);\n\n    if (request.useElectronNet) {\n      for (const headerName in headers) {\n        if (typeof headers[headerName] === 'string') req.setHeader(headerName, headers[headerName]);else {\n          for (var _iterator = _createForOfIteratorHelperLoose(headers[headerName]), _step; !(_step = _iterator()).done;) {\n            const headerValue = _step.value;\n            req.setHeader(headerName, headerValue);\n          }\n        }\n      }\n    }\n\n    let reqTimeout;\n\n    const cancelRequest = () => {\n      if (request.useElectronNet) {\n        req.abort(); // in electron, `req.destroy()` does not send abort to server\n      } else {\n        req.destroy(); // in node.js, `req.abort()` is deprecated\n      }\n    };\n\n    const abortRequest = () => {\n      const err = new FetchError('request aborted', 'abort');\n      reject(err);\n      cancelRequest();\n      req.emit('error', err);\n    };\n\n    if (request.signal) {\n      request.signal.addEventListener('abort', abortRequest);\n    }\n\n    if (request.timeout) {\n      reqTimeout = setTimeout(() => {\n        const err = new FetchError(`network timeout at: ${request.url}`, 'request-timeout');\n        reject(err);\n        cancelRequest();\n      }, request.timeout);\n    }\n\n    if (request.useElectronNet) {\n      // handle authenticating proxies\n      req.on('login', (authInfo, callback) => {\n        if (opts.user && opts.password) {\n          callback(opts.user, opts.password);\n        } else if (opts.onLogin) {\n          opts.onLogin(authInfo).then(credentials => {\n            if (credentials) {\n              callback(credentials.username, credentials.password);\n            } else {\n              callback();\n            }\n          }).catch(error => {\n            cancelRequest();\n            reject(error);\n          });\n        } else {\n          cancelRequest();\n          reject(new FetchError(`login event received from ${authInfo.host} but no credentials or onLogin handler provided`, 'proxy', {\n            code: 'PROXY_AUTH_FAILED'\n          }));\n        }\n      });\n    }\n\n    req.on('error', err => {\n      clearTimeout(reqTimeout);\n\n      if (request.signal) {\n        request.signal.removeEventListener('abort', abortRequest);\n      }\n\n      reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, 'system', err));\n    });\n    req.on('abort', () => {\n      clearTimeout(reqTimeout);\n\n      if (request.signal) {\n        request.signal.removeEventListener('abort', abortRequest);\n      }\n    });\n    req.on('response', res => {\n      try {\n        clearTimeout(reqTimeout);\n\n        if (request.signal) {\n          request.signal.removeEventListener('abort', abortRequest);\n        } // handle redirect\n\n\n        if (fetch.isRedirect(res.statusCode) && request.redirect !== 'manual') {\n          if (request.redirect === 'error') {\n            reject(new FetchError(`redirect mode is set to error: ${request.url}`, 'no-redirect'));\n            return;\n          }\n\n          if (request.counter >= request.follow) {\n            reject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));\n            return;\n          }\n\n          if (!res.headers.location) {\n            reject(new FetchError(`redirect location header missing at: ${request.url}`, 'invalid-redirect'));\n            return;\n          } // per fetch spec, for POST request with 301/302 response, or any request with 303 response, use GET when following redirect\n\n\n          if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {\n            request.method = 'GET';\n            request.body = null;\n            request.headers.delete('content-length');\n          }\n\n          request.counter++;\n          resolve$1(fetch(resolve(request.url, res.headers.location), request));\n          return;\n        } // normalize location header for manual redirect mode\n\n\n        const headers = new Headers();\n\n        for (var _i = 0, _Object$keys = Object.keys(res.headers); _i < _Object$keys.length; _i++) {\n          const name = _Object$keys[_i];\n\n          if (Array.isArray(res.headers[name])) {\n            for (var _iterator2 = _createForOfIteratorHelperLoose(res.headers[name]), _step2; !(_step2 = _iterator2()).done;) {\n              const val = _step2.value;\n              headers.append(name, val);\n            }\n          } else {\n            headers.append(name, res.headers[name]);\n          }\n        }\n\n        if (request.redirect === 'manual' && headers.has('location')) {\n          headers.set('location', resolve(request.url, headers.get('location')));\n        } // prepare response\n\n\n        let body = new PassThrough();\n        res.on('error', err => body.emit('error', err));\n        res.pipe(body);\n        body.on('error', cancelRequest);\n        body.on('cancel-request', cancelRequest);\n\n        const abortBody = () => {\n          res.destroy();\n          res.emit('error', new FetchError('request aborted', 'abort')); // separated from the `.destroy()` because somehow Node's IncomingMessage streams do not emit errors on destroy\n        };\n\n        if (request.signal) {\n          request.signal.addEventListener('abort', abortBody);\n          res.on('end', () => {\n            request.signal.removeEventListener('abort', abortBody);\n          });\n          res.on('error', () => {\n            request.signal.removeEventListener('abort', abortBody);\n          });\n        }\n\n        const responseOptions = {\n          url: request.url,\n          status: res.statusCode,\n          statusText: res.statusMessage,\n          headers,\n          size: request.size,\n          timeout: request.timeout,\n          useElectronNet: request.useElectronNet,\n          useSessionCookies: request.useSessionCookies\n        }; // HTTP-network fetch step 16.1.2\n\n        const codings = headers.get('Content-Encoding'); // HTTP-network fetch step 16.1.3: handle content codings\n        // in following scenarios we ignore compression support\n        // 1. running on Electron/net module (it manages it for us)\n        // 2. HEAD request\n        // 3. no Content-Encoding header\n        // 4. no content response (204)\n        // 5. content not modified response (304)\n\n        if (!request.useElectronNet && request.method !== 'HEAD' && codings !== null && res.statusCode !== 204 && res.statusCode !== 304) {\n          // Be less strict when decoding compressed responses, since sometimes\n          // servers send slightly invalid responses that are still accepted\n          // by common browsers.\n          // Always using Z_SYNC_FLUSH is what cURL does.\n          // /!\\ This is disabled for now, because it seems broken in recent node\n          // const zlibOptions = {\n          //   flush: zlib.Z_SYNC_FLUSH,\n          //   finishFlush: zlib.Z_SYNC_FLUSH\n          // }\n          if (codings === 'gzip' || codings === 'x-gzip') {\n            // for gzip\n            body = body.pipe(zlib.createGunzip());\n          } else if (codings === 'deflate' || codings === 'x-deflate') {\n            // for deflate\n            // handle the infamous raw deflate response from old servers\n            // a hack for old IIS and Apache servers\n            const raw = res.pipe(new PassThrough());\n            return raw.once('data', chunk => {\n              // see http://stackoverflow.com/questions/37519828\n              if ((chunk[0] & 0x0F) === 0x08) {\n                body = body.pipe(zlib.createInflate());\n              } else {\n                body = body.pipe(zlib.createInflateRaw());\n              }\n\n              const response = new Response(body, responseOptions);\n              resolve$1(response);\n            });\n          }\n        }\n\n        const response = new Response(body, responseOptions);\n        resolve$1(response);\n      } catch (error) {\n        reject(new FetchError(`Invalid response: ${error.message}`, 'invalid-response'));\n        cancelRequest();\n      }\n    });\n    writeToStream(req, request);\n  }));\n}\n/**\n * Redirect code matching\n *\n * @param {number} code Status code\n * @return {boolean}\n */\n\nfetch.isRedirect = code => code === 301 || code === 302 || code === 303 || code === 307 || code === 308;\n\nexport { FetchError, Headers, Request, Response, fetch as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}