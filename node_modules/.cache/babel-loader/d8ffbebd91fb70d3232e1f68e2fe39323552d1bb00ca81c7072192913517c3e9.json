{"ast":null,"code":"var BIT_16 = Math.pow(2, 16);\nvar BIT_24 = Math.pow(2, 24);\nvar BUFFER_ALLOC_SIZE = Math.pow(2, 8);\n// The maximum precision JS Numbers can hold precisely\n// Don't panic: Good enough to represent byte values up to 8192 TB\nvar IEEE_754_BINARY_64_PRECISION = Math.pow(2, 53);\nvar MAX_PACKET_LENGTH = Math.pow(2, 24) - 1;\nvar Buffer = require('safe-buffer').Buffer;\nmodule.exports = PacketWriter;\nfunction PacketWriter() {\n  this._buffer = null;\n  this._offset = 0;\n}\nPacketWriter.prototype.toBuffer = function toBuffer(parser) {\n  if (!this._buffer) {\n    this._buffer = Buffer.alloc(0);\n    this._offset = 0;\n  }\n  var buffer = this._buffer;\n  var length = this._offset;\n  var packets = Math.floor(length / MAX_PACKET_LENGTH) + 1;\n  this._buffer = Buffer.allocUnsafe(length + packets * 4);\n  this._offset = 0;\n  for (var packet = 0; packet < packets; packet++) {\n    var isLast = packet + 1 === packets;\n    var packetLength = isLast ? length % MAX_PACKET_LENGTH : MAX_PACKET_LENGTH;\n    var packetNumber = parser.incrementPacketNumber();\n    this.writeUnsignedNumber(3, packetLength);\n    this.writeUnsignedNumber(1, packetNumber);\n    var start = packet * MAX_PACKET_LENGTH;\n    var end = start + packetLength;\n    this.writeBuffer(buffer.slice(start, end));\n  }\n  return this._buffer;\n};\nPacketWriter.prototype.writeUnsignedNumber = function (bytes, value) {\n  this._allocate(bytes);\n  for (var i = 0; i < bytes; i++) {\n    this._buffer[this._offset++] = value >> i * 8 & 0xff;\n  }\n};\nPacketWriter.prototype.writeFiller = function (bytes) {\n  this._allocate(bytes);\n  for (var i = 0; i < bytes; i++) {\n    this._buffer[this._offset++] = 0x00;\n  }\n};\nPacketWriter.prototype.writeNullTerminatedString = function (value, encoding) {\n  // Typecast undefined into '' and numbers into strings\n  value = value || '';\n  value = value + '';\n  var bytes = Buffer.byteLength(value, encoding || 'utf-8') + 1;\n  this._allocate(bytes);\n  this._buffer.write(value, this._offset, encoding);\n  this._buffer[this._offset + bytes - 1] = 0x00;\n  this._offset += bytes;\n};\nPacketWriter.prototype.writeString = function (value) {\n  // Typecast undefined into '' and numbers into strings\n  value = value || '';\n  value = value + '';\n  var bytes = Buffer.byteLength(value, 'utf-8');\n  this._allocate(bytes);\n  this._buffer.write(value, this._offset, 'utf-8');\n  this._offset += bytes;\n};\nPacketWriter.prototype.writeBuffer = function (value) {\n  var bytes = value.length;\n  this._allocate(bytes);\n  value.copy(this._buffer, this._offset);\n  this._offset += bytes;\n};\nPacketWriter.prototype.writeLengthCodedNumber = function (value) {\n  if (value === null) {\n    this._allocate(1);\n    this._buffer[this._offset++] = 251;\n    return;\n  }\n  if (value <= 250) {\n    this._allocate(1);\n    this._buffer[this._offset++] = value;\n    return;\n  }\n  if (value > IEEE_754_BINARY_64_PRECISION) {\n    throw new Error('writeLengthCodedNumber: JS precision range exceeded, your ' + 'number is > 53 bit: \"' + value + '\"');\n  }\n  if (value < BIT_16) {\n    this._allocate(3);\n    this._buffer[this._offset++] = 252;\n  } else if (value < BIT_24) {\n    this._allocate(4);\n    this._buffer[this._offset++] = 253;\n  } else {\n    this._allocate(9);\n    this._buffer[this._offset++] = 254;\n  }\n\n  // 16 Bit\n  this._buffer[this._offset++] = value & 0xff;\n  this._buffer[this._offset++] = value >> 8 & 0xff;\n  if (value < BIT_16) {\n    return;\n  }\n\n  // 24 Bit\n  this._buffer[this._offset++] = value >> 16 & 0xff;\n  if (value < BIT_24) {\n    return;\n  }\n  this._buffer[this._offset++] = value >> 24 & 0xff;\n\n  // Hack: Get the most significant 32 bit (JS bitwise operators are 32 bit)\n  value = value.toString(2);\n  value = value.substr(0, value.length - 32);\n  value = parseInt(value, 2);\n  this._buffer[this._offset++] = value & 0xff;\n  this._buffer[this._offset++] = value >> 8 & 0xff;\n  this._buffer[this._offset++] = value >> 16 & 0xff;\n\n  // Set last byte to 0, as we can only support 53 bits in JS (see above)\n  this._buffer[this._offset++] = 0;\n};\nPacketWriter.prototype.writeLengthCodedBuffer = function (value) {\n  var bytes = value.length;\n  this.writeLengthCodedNumber(bytes);\n  this.writeBuffer(value);\n};\nPacketWriter.prototype.writeNullTerminatedBuffer = function (value) {\n  this.writeBuffer(value);\n  this.writeFiller(1); // 0x00 terminator\n};\n\nPacketWriter.prototype.writeLengthCodedString = function (value) {\n  if (value === null) {\n    this.writeLengthCodedNumber(null);\n    return;\n  }\n  value = value === undefined ? '' : String(value);\n  var bytes = Buffer.byteLength(value, 'utf-8');\n  this.writeLengthCodedNumber(bytes);\n  if (!bytes) {\n    return;\n  }\n  this._allocate(bytes);\n  this._buffer.write(value, this._offset, 'utf-8');\n  this._offset += bytes;\n};\nPacketWriter.prototype._allocate = function _allocate(bytes) {\n  if (!this._buffer) {\n    this._buffer = Buffer.alloc(Math.max(BUFFER_ALLOC_SIZE, bytes));\n    this._offset = 0;\n    return;\n  }\n  var bytesRemaining = this._buffer.length - this._offset;\n  if (bytesRemaining >= bytes) {\n    return;\n  }\n  var newSize = this._buffer.length + Math.max(BUFFER_ALLOC_SIZE, bytes);\n  var oldBuffer = this._buffer;\n  this._buffer = Buffer.alloc(newSize);\n  oldBuffer.copy(this._buffer);\n};","map":{"version":3,"names":["BIT_16","Math","pow","BIT_24","BUFFER_ALLOC_SIZE","IEEE_754_BINARY_64_PRECISION","MAX_PACKET_LENGTH","Buffer","require","module","exports","PacketWriter","_buffer","_offset","prototype","toBuffer","parser","alloc","buffer","length","packets","floor","allocUnsafe","packet","isLast","packetLength","packetNumber","incrementPacketNumber","writeUnsignedNumber","start","end","writeBuffer","slice","bytes","value","_allocate","i","writeFiller","writeNullTerminatedString","encoding","byteLength","write","writeString","copy","writeLengthCodedNumber","Error","toString","substr","parseInt","writeLengthCodedBuffer","writeNullTerminatedBuffer","writeLengthCodedString","undefined","String","max","bytesRemaining","newSize","oldBuffer"],"sources":["D:/BNH/vizsgaremek/node_modules/mysql/lib/protocol/PacketWriter.js"],"sourcesContent":["var BIT_16            = Math.pow(2, 16);\nvar BIT_24            = Math.pow(2, 24);\nvar BUFFER_ALLOC_SIZE = Math.pow(2, 8);\n// The maximum precision JS Numbers can hold precisely\n// Don't panic: Good enough to represent byte values up to 8192 TB\nvar IEEE_754_BINARY_64_PRECISION = Math.pow(2, 53);\nvar MAX_PACKET_LENGTH            = Math.pow(2, 24) - 1;\nvar Buffer                       = require('safe-buffer').Buffer;\n\nmodule.exports = PacketWriter;\nfunction PacketWriter() {\n  this._buffer = null;\n  this._offset = 0;\n}\n\nPacketWriter.prototype.toBuffer = function toBuffer(parser) {\n  if (!this._buffer) {\n    this._buffer = Buffer.alloc(0);\n    this._offset = 0;\n  }\n\n  var buffer  = this._buffer;\n  var length  = this._offset;\n  var packets = Math.floor(length / MAX_PACKET_LENGTH) + 1;\n\n  this._buffer = Buffer.allocUnsafe(length + packets * 4);\n  this._offset = 0;\n\n  for (var packet = 0; packet < packets; packet++) {\n    var isLast = (packet + 1 === packets);\n    var packetLength = (isLast)\n      ? length % MAX_PACKET_LENGTH\n      : MAX_PACKET_LENGTH;\n\n    var packetNumber = parser.incrementPacketNumber();\n\n    this.writeUnsignedNumber(3, packetLength);\n    this.writeUnsignedNumber(1, packetNumber);\n\n    var start = packet * MAX_PACKET_LENGTH;\n    var end   = start + packetLength;\n\n    this.writeBuffer(buffer.slice(start, end));\n  }\n\n  return this._buffer;\n};\n\nPacketWriter.prototype.writeUnsignedNumber = function(bytes, value) {\n  this._allocate(bytes);\n\n  for (var i = 0; i < bytes; i++) {\n    this._buffer[this._offset++] = (value >> (i * 8)) & 0xff;\n  }\n};\n\nPacketWriter.prototype.writeFiller = function(bytes) {\n  this._allocate(bytes);\n\n  for (var i = 0; i < bytes; i++) {\n    this._buffer[this._offset++] = 0x00;\n  }\n};\n\nPacketWriter.prototype.writeNullTerminatedString = function(value, encoding) {\n  // Typecast undefined into '' and numbers into strings\n  value = value || '';\n  value = value + '';\n\n  var bytes = Buffer.byteLength(value, encoding || 'utf-8') + 1;\n  this._allocate(bytes);\n\n  this._buffer.write(value, this._offset, encoding);\n  this._buffer[this._offset + bytes - 1] = 0x00;\n\n  this._offset += bytes;\n};\n\nPacketWriter.prototype.writeString = function(value) {\n  // Typecast undefined into '' and numbers into strings\n  value = value || '';\n  value = value + '';\n\n  var bytes = Buffer.byteLength(value, 'utf-8');\n  this._allocate(bytes);\n\n  this._buffer.write(value, this._offset, 'utf-8');\n\n  this._offset += bytes;\n};\n\nPacketWriter.prototype.writeBuffer = function(value) {\n  var bytes = value.length;\n\n  this._allocate(bytes);\n  value.copy(this._buffer, this._offset);\n  this._offset += bytes;\n};\n\nPacketWriter.prototype.writeLengthCodedNumber = function(value) {\n  if (value === null) {\n    this._allocate(1);\n    this._buffer[this._offset++] = 251;\n    return;\n  }\n\n  if (value <= 250) {\n    this._allocate(1);\n    this._buffer[this._offset++] = value;\n    return;\n  }\n\n  if (value > IEEE_754_BINARY_64_PRECISION) {\n    throw new Error(\n      'writeLengthCodedNumber: JS precision range exceeded, your ' +\n      'number is > 53 bit: \"' + value + '\"'\n    );\n  }\n\n  if (value < BIT_16) {\n    this._allocate(3);\n    this._buffer[this._offset++] = 252;\n  } else if (value < BIT_24) {\n    this._allocate(4);\n    this._buffer[this._offset++] = 253;\n  } else {\n    this._allocate(9);\n    this._buffer[this._offset++] = 254;\n  }\n\n  // 16 Bit\n  this._buffer[this._offset++] = value & 0xff;\n  this._buffer[this._offset++] = (value >> 8) & 0xff;\n\n  if (value < BIT_16) {\n    return;\n  }\n\n  // 24 Bit\n  this._buffer[this._offset++] = (value >> 16) & 0xff;\n\n  if (value < BIT_24) {\n    return;\n  }\n\n  this._buffer[this._offset++] = (value >> 24) & 0xff;\n\n  // Hack: Get the most significant 32 bit (JS bitwise operators are 32 bit)\n  value = value.toString(2);\n  value = value.substr(0, value.length - 32);\n  value = parseInt(value, 2);\n\n  this._buffer[this._offset++] = value & 0xff;\n  this._buffer[this._offset++] = (value >> 8) & 0xff;\n  this._buffer[this._offset++] = (value >> 16) & 0xff;\n\n  // Set last byte to 0, as we can only support 53 bits in JS (see above)\n  this._buffer[this._offset++] = 0;\n};\n\nPacketWriter.prototype.writeLengthCodedBuffer = function(value) {\n  var bytes = value.length;\n  this.writeLengthCodedNumber(bytes);\n  this.writeBuffer(value);\n};\n\nPacketWriter.prototype.writeNullTerminatedBuffer = function(value) {\n  this.writeBuffer(value);\n  this.writeFiller(1); // 0x00 terminator\n};\n\nPacketWriter.prototype.writeLengthCodedString = function(value) {\n  if (value === null) {\n    this.writeLengthCodedNumber(null);\n    return;\n  }\n\n  value = (value === undefined)\n    ? ''\n    : String(value);\n\n  var bytes = Buffer.byteLength(value, 'utf-8');\n  this.writeLengthCodedNumber(bytes);\n\n  if (!bytes) {\n    return;\n  }\n\n  this._allocate(bytes);\n  this._buffer.write(value, this._offset, 'utf-8');\n  this._offset += bytes;\n};\n\nPacketWriter.prototype._allocate = function _allocate(bytes) {\n  if (!this._buffer) {\n    this._buffer = Buffer.alloc(Math.max(BUFFER_ALLOC_SIZE, bytes));\n    this._offset = 0;\n    return;\n  }\n\n  var bytesRemaining = this._buffer.length - this._offset;\n  if (bytesRemaining >= bytes) {\n    return;\n  }\n\n  var newSize   = this._buffer.length + Math.max(BUFFER_ALLOC_SIZE, bytes);\n  var oldBuffer = this._buffer;\n\n  this._buffer = Buffer.alloc(newSize);\n  oldBuffer.copy(this._buffer);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}