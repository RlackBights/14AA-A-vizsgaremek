{"ast":null,"code":"var Parser = require('./Parser');\nvar Sequences = require('./sequences');\nvar Packets = require('./packets');\nvar Stream = require('stream').Stream;\nvar Util = require('util');\nvar PacketWriter = require('./PacketWriter');\nmodule.exports = Protocol;\nUtil.inherits(Protocol, Stream);\nfunction Protocol(options) {\n  Stream.call(this);\n  options = options || {};\n  this.readable = true;\n  this.writable = true;\n  this._config = options.config || {};\n  this._connection = options.connection;\n  this._callback = null;\n  this._fatalError = null;\n  this._quitSequence = null;\n  this._handshake = false;\n  this._handshaked = false;\n  this._ended = false;\n  this._destroyed = false;\n  this._queue = [];\n  this._handshakeInitializationPacket = null;\n  this._parser = new Parser({\n    onError: this.handleParserError.bind(this),\n    onPacket: this._parsePacket.bind(this),\n    config: this._config\n  });\n}\nProtocol.prototype.write = function (buffer) {\n  this._parser.write(buffer);\n  return true;\n};\nProtocol.prototype.handshake = function handshake(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  options.config = this._config;\n  var sequence = this._enqueue(new Sequences.Handshake(options, callback));\n  this._handshake = true;\n  return sequence;\n};\nProtocol.prototype.query = function query(options, callback) {\n  return this._enqueue(new Sequences.Query(options, callback));\n};\nProtocol.prototype.changeUser = function changeUser(options, callback) {\n  return this._enqueue(new Sequences.ChangeUser(options, callback));\n};\nProtocol.prototype.ping = function ping(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  return this._enqueue(new Sequences.Ping(options, callback));\n};\nProtocol.prototype.stats = function stats(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  return this._enqueue(new Sequences.Statistics(options, callback));\n};\nProtocol.prototype.quit = function quit(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  var self = this;\n  var sequence = this._enqueue(new Sequences.Quit(options, callback));\n  sequence.on('end', function () {\n    self.end();\n  });\n  return this._quitSequence = sequence;\n};\nProtocol.prototype.end = function () {\n  if (this._ended) {\n    return;\n  }\n  this._ended = true;\n  if (this._quitSequence && (this._quitSequence._ended || this._queue[0] === this._quitSequence)) {\n    this._quitSequence.end();\n    this.emit('end');\n    return;\n  }\n  var err = new Error('Connection lost: The server closed the connection.');\n  err.fatal = true;\n  err.code = 'PROTOCOL_CONNECTION_LOST';\n  this._delegateError(err);\n};\nProtocol.prototype.pause = function () {\n  this._parser.pause();\n  // Since there is a file stream in query, we must transmit pause/resume event to current sequence.\n  var seq = this._queue[0];\n  if (seq && seq.emit) {\n    seq.emit('pause');\n  }\n};\nProtocol.prototype.resume = function () {\n  this._parser.resume();\n  // Since there is a file stream in query, we must transmit pause/resume event to current sequence.\n  var seq = this._queue[0];\n  if (seq && seq.emit) {\n    seq.emit('resume');\n  }\n};\nProtocol.prototype._enqueue = function (sequence) {\n  if (!this._validateEnqueue(sequence)) {\n    return sequence;\n  }\n  if (this._config.trace) {\n    // Long stack trace support\n    sequence._callSite = sequence._callSite || new Error();\n  }\n  this._queue.push(sequence);\n  this.emit('enqueue', sequence);\n  var self = this;\n  sequence.on('error', function (err) {\n    self._delegateError(err, sequence);\n  }).on('packet', function (packet) {\n    sequence._timer.active();\n    self._emitPacket(packet);\n  }).on('timeout', function () {\n    var err = new Error(sequence.constructor.name + ' inactivity timeout');\n    err.code = 'PROTOCOL_SEQUENCE_TIMEOUT';\n    err.fatal = true;\n    err.timeout = sequence._timeout;\n    self._delegateError(err, sequence);\n  });\n  if (sequence.constructor === Sequences.Handshake) {\n    sequence.on('start-tls', function () {\n      sequence._timer.active();\n      self._connection._startTLS(function (err) {\n        if (err) {\n          // SSL negotiation error are fatal\n          err.code = 'HANDSHAKE_SSL_ERROR';\n          err.fatal = true;\n          sequence.end(err);\n          return;\n        }\n        sequence._timer.active();\n        sequence._tlsUpgradeCompleteHandler();\n      });\n    });\n    sequence.on('end', function () {\n      self._handshaked = true;\n      if (!self._fatalError) {\n        self.emit('handshake', self._handshakeInitializationPacket);\n      }\n    });\n  }\n  sequence.on('end', function () {\n    self._dequeue(sequence);\n  });\n  if (this._queue.length === 1) {\n    this._parser.resetPacketNumber();\n    this._startSequence(sequence);\n  }\n  return sequence;\n};\nProtocol.prototype._validateEnqueue = function _validateEnqueue(sequence) {\n  var err;\n  var prefix = 'Cannot enqueue ' + sequence.constructor.name;\n  if (this._fatalError) {\n    err = new Error(prefix + ' after fatal error.');\n    err.code = 'PROTOCOL_ENQUEUE_AFTER_FATAL_ERROR';\n  } else if (this._quitSequence) {\n    err = new Error(prefix + ' after invoking quit.');\n    err.code = 'PROTOCOL_ENQUEUE_AFTER_QUIT';\n  } else if (this._destroyed) {\n    err = new Error(prefix + ' after being destroyed.');\n    err.code = 'PROTOCOL_ENQUEUE_AFTER_DESTROY';\n  } else if ((this._handshake || this._handshaked) && sequence.constructor === Sequences.Handshake) {\n    err = new Error(prefix + ' after already enqueuing a Handshake.');\n    err.code = 'PROTOCOL_ENQUEUE_HANDSHAKE_TWICE';\n  } else {\n    return true;\n  }\n  var self = this;\n  err.fatal = false;\n\n  // add error handler\n  sequence.on('error', function (err) {\n    self._delegateError(err, sequence);\n  });\n  process.nextTick(function () {\n    sequence.end(err);\n  });\n  return false;\n};\nProtocol.prototype._parsePacket = function () {\n  var sequence = this._queue[0];\n  if (!sequence) {\n    var err = new Error('Received packet with no active sequence.');\n    err.code = 'PROTOCOL_STRAY_PACKET';\n    err.fatal = true;\n    this._delegateError(err);\n    return;\n  }\n  var Packet = this._determinePacket(sequence);\n  var packet = new Packet({\n    protocol41: this._config.protocol41\n  });\n  var packetName = Packet.name;\n\n  // Special case: Faster dispatch, and parsing done inside sequence\n  if (Packet === Packets.RowDataPacket) {\n    sequence.RowDataPacket(packet, this._parser, this._connection);\n    if (this._config.debug) {\n      this._debugPacket(true, packet);\n    }\n    return;\n  }\n  if (this._config.debug) {\n    this._parsePacketDebug(packet);\n  } else {\n    packet.parse(this._parser);\n  }\n  if (Packet === Packets.HandshakeInitializationPacket) {\n    this._handshakeInitializationPacket = packet;\n    this.emit('initialize', packet);\n  }\n  sequence._timer.active();\n  if (!sequence[packetName]) {\n    var err = new Error('Received packet in the wrong sequence.');\n    err.code = 'PROTOCOL_INCORRECT_PACKET_SEQUENCE';\n    err.fatal = true;\n    this._delegateError(err);\n    return;\n  }\n  sequence[packetName](packet);\n};\nProtocol.prototype._parsePacketDebug = function _parsePacketDebug(packet) {\n  try {\n    packet.parse(this._parser);\n  } finally {\n    this._debugPacket(true, packet);\n  }\n};\nProtocol.prototype._emitPacket = function (packet) {\n  var packetWriter = new PacketWriter();\n  packet.write(packetWriter);\n  this.emit('data', packetWriter.toBuffer(this._parser));\n  if (this._config.debug) {\n    this._debugPacket(false, packet);\n  }\n};\nProtocol.prototype._determinePacket = function (sequence) {\n  var firstByte = this._parser.peak();\n  if (sequence.determinePacket) {\n    var Packet = sequence.determinePacket(firstByte, this._parser);\n    if (Packet) {\n      return Packet;\n    }\n  }\n  switch (firstByte) {\n    case 0x00:\n      return Packets.OkPacket;\n    case 0xfe:\n      return Packets.EofPacket;\n    case 0xff:\n      return Packets.ErrorPacket;\n  }\n  throw new Error('Could not determine packet, firstByte = ' + firstByte);\n};\nProtocol.prototype._dequeue = function (sequence) {\n  sequence._timer.stop();\n\n  // No point in advancing the queue, we are dead\n  if (this._fatalError) {\n    return;\n  }\n  this._queue.shift();\n  var sequence = this._queue[0];\n  if (!sequence) {\n    this.emit('drain');\n    return;\n  }\n  this._parser.resetPacketNumber();\n  this._startSequence(sequence);\n};\nProtocol.prototype._startSequence = function (sequence) {\n  if (sequence._timeout > 0 && isFinite(sequence._timeout)) {\n    sequence._timer.start(sequence._timeout);\n  }\n  if (sequence.constructor === Sequences.ChangeUser) {\n    sequence.start(this._handshakeInitializationPacket);\n  } else {\n    sequence.start();\n  }\n};\nProtocol.prototype.handleNetworkError = function (err) {\n  err.fatal = true;\n  var sequence = this._queue[0];\n  if (sequence) {\n    sequence.end(err);\n  } else {\n    this._delegateError(err);\n  }\n};\nProtocol.prototype.handleParserError = function handleParserError(err) {\n  var sequence = this._queue[0];\n  if (sequence) {\n    sequence.end(err);\n  } else {\n    this._delegateError(err);\n  }\n};\nProtocol.prototype._delegateError = function (err, sequence) {\n  // Stop delegating errors after the first fatal error\n  if (this._fatalError) {\n    return;\n  }\n  if (err.fatal) {\n    this._fatalError = err;\n  }\n  if (this._shouldErrorBubbleUp(err, sequence)) {\n    // Can't use regular 'error' event here as that always destroys the pipe\n    // between socket and protocol which is not what we want (unless the\n    // exception was fatal).\n    this.emit('unhandledError', err);\n  } else if (err.fatal) {\n    // Send fatal error to all sequences in the queue\n    var queue = this._queue;\n    process.nextTick(function () {\n      queue.forEach(function (sequence) {\n        sequence.end(err);\n      });\n      queue.length = 0;\n    });\n  }\n\n  // Make sure the stream we are piping to is getting closed\n  if (err.fatal) {\n    this.emit('end', err);\n  }\n};\nProtocol.prototype._shouldErrorBubbleUp = function (err, sequence) {\n  if (sequence) {\n    if (sequence.hasErrorHandler()) {\n      return false;\n    } else if (!err.fatal) {\n      return true;\n    }\n  }\n  return err.fatal && !this._hasPendingErrorHandlers();\n};\nProtocol.prototype._hasPendingErrorHandlers = function () {\n  return this._queue.some(function (sequence) {\n    return sequence.hasErrorHandler();\n  });\n};\nProtocol.prototype.destroy = function () {\n  this._destroyed = true;\n  this._parser.pause();\n  if (this._connection.state !== 'disconnected') {\n    if (!this._ended) {\n      this.end();\n    }\n  }\n};\nProtocol.prototype._debugPacket = function (incoming, packet) {\n  var connection = this._connection;\n  var direction = incoming ? '<--' : '-->';\n  var packetName = packet.constructor.name;\n  var threadId = connection && connection.threadId !== null ? ' (' + connection.threadId + ')' : '';\n\n  // check for debug packet restriction\n  if (Array.isArray(this._config.debug) && this._config.debug.indexOf(packetName) === -1) {\n    return;\n  }\n  var packetPayload = Util.inspect(packet).replace(/^[^{]+/, '');\n  console.log('%s%s %s %s\\n', direction, threadId, packetName, packetPayload);\n};","map":{"version":3,"names":["Parser","require","Sequences","Packets","Stream","Util","PacketWriter","module","exports","Protocol","inherits","options","call","readable","writable","_config","config","_connection","connection","_callback","_fatalError","_quitSequence","_handshake","_handshaked","_ended","_destroyed","_queue","_handshakeInitializationPacket","_parser","onError","handleParserError","bind","onPacket","_parsePacket","prototype","write","buffer","handshake","callback","sequence","_enqueue","Handshake","query","Query","changeUser","ChangeUser","ping","Ping","stats","Statistics","quit","self","Quit","on","end","emit","err","Error","fatal","code","_delegateError","pause","seq","resume","_validateEnqueue","trace","_callSite","push","packet","_timer","active","_emitPacket","constructor","name","timeout","_timeout","_startTLS","_tlsUpgradeCompleteHandler","_dequeue","length","resetPacketNumber","_startSequence","prefix","process","nextTick","Packet","_determinePacket","protocol41","packetName","RowDataPacket","debug","_debugPacket","_parsePacketDebug","parse","HandshakeInitializationPacket","packetWriter","toBuffer","firstByte","peak","determinePacket","OkPacket","EofPacket","ErrorPacket","stop","shift","isFinite","start","handleNetworkError","_shouldErrorBubbleUp","queue","forEach","hasErrorHandler","_hasPendingErrorHandlers","some","destroy","state","incoming","direction","threadId","Array","isArray","indexOf","packetPayload","inspect","replace","console","log"],"sources":["D:/BNH/vizsgaremek/node_modules/mysql/lib/protocol/Protocol.js"],"sourcesContent":["var Parser       = require('./Parser');\nvar Sequences    = require('./sequences');\nvar Packets      = require('./packets');\nvar Stream       = require('stream').Stream;\nvar Util         = require('util');\nvar PacketWriter = require('./PacketWriter');\n\nmodule.exports = Protocol;\nUtil.inherits(Protocol, Stream);\nfunction Protocol(options) {\n  Stream.call(this);\n\n  options = options || {};\n\n  this.readable = true;\n  this.writable = true;\n\n  this._config                        = options.config || {};\n  this._connection                    = options.connection;\n  this._callback                      = null;\n  this._fatalError                    = null;\n  this._quitSequence                  = null;\n  this._handshake                     = false;\n  this._handshaked                    = false;\n  this._ended                         = false;\n  this._destroyed                     = false;\n  this._queue                         = [];\n  this._handshakeInitializationPacket = null;\n\n  this._parser = new Parser({\n    onError  : this.handleParserError.bind(this),\n    onPacket : this._parsePacket.bind(this),\n    config   : this._config\n  });\n}\n\nProtocol.prototype.write = function(buffer) {\n  this._parser.write(buffer);\n  return true;\n};\n\nProtocol.prototype.handshake = function handshake(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n  options.config = this._config;\n\n  var sequence = this._enqueue(new Sequences.Handshake(options, callback));\n\n  this._handshake = true;\n\n  return sequence;\n};\n\nProtocol.prototype.query = function query(options, callback) {\n  return this._enqueue(new Sequences.Query(options, callback));\n};\n\nProtocol.prototype.changeUser = function changeUser(options, callback) {\n  return this._enqueue(new Sequences.ChangeUser(options, callback));\n};\n\nProtocol.prototype.ping = function ping(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  return this._enqueue(new Sequences.Ping(options, callback));\n};\n\nProtocol.prototype.stats = function stats(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  return this._enqueue(new Sequences.Statistics(options, callback));\n};\n\nProtocol.prototype.quit = function quit(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  var self     = this;\n  var sequence = this._enqueue(new Sequences.Quit(options, callback));\n\n  sequence.on('end', function () {\n    self.end();\n  });\n\n  return this._quitSequence = sequence;\n};\n\nProtocol.prototype.end = function() {\n  if (this._ended) {\n    return;\n  }\n  this._ended = true;\n\n  if (this._quitSequence && (this._quitSequence._ended || this._queue[0] === this._quitSequence)) {\n    this._quitSequence.end();\n    this.emit('end');\n    return;\n  }\n\n  var err = new Error('Connection lost: The server closed the connection.');\n  err.fatal = true;\n  err.code = 'PROTOCOL_CONNECTION_LOST';\n\n  this._delegateError(err);\n};\n\nProtocol.prototype.pause = function() {\n  this._parser.pause();\n  // Since there is a file stream in query, we must transmit pause/resume event to current sequence.\n  var seq = this._queue[0];\n  if (seq && seq.emit) {\n    seq.emit('pause');\n  }\n};\n\nProtocol.prototype.resume = function() {\n  this._parser.resume();\n  // Since there is a file stream in query, we must transmit pause/resume event to current sequence.\n  var seq = this._queue[0];\n  if (seq && seq.emit) {\n    seq.emit('resume');\n  }\n};\n\nProtocol.prototype._enqueue = function(sequence) {\n  if (!this._validateEnqueue(sequence)) {\n    return sequence;\n  }\n\n  if (this._config.trace) {\n    // Long stack trace support\n    sequence._callSite = sequence._callSite || new Error();\n  }\n\n  this._queue.push(sequence);\n  this.emit('enqueue', sequence);\n\n  var self = this;\n  sequence\n    .on('error', function(err) {\n      self._delegateError(err, sequence);\n    })\n    .on('packet', function(packet) {\n      sequence._timer.active();\n      self._emitPacket(packet);\n    })\n    .on('timeout', function() {\n      var err = new Error(sequence.constructor.name + ' inactivity timeout');\n\n      err.code    = 'PROTOCOL_SEQUENCE_TIMEOUT';\n      err.fatal   = true;\n      err.timeout = sequence._timeout;\n\n      self._delegateError(err, sequence);\n    });\n\n  if (sequence.constructor === Sequences.Handshake) {\n    sequence.on('start-tls', function () {\n      sequence._timer.active();\n      self._connection._startTLS(function(err) {\n        if (err) {\n          // SSL negotiation error are fatal\n          err.code  = 'HANDSHAKE_SSL_ERROR';\n          err.fatal = true;\n          sequence.end(err);\n          return;\n        }\n\n        sequence._timer.active();\n        sequence._tlsUpgradeCompleteHandler();\n      });\n    });\n\n    sequence.on('end', function () {\n      self._handshaked = true;\n\n      if (!self._fatalError) {\n        self.emit('handshake', self._handshakeInitializationPacket);\n      }\n    });\n  }\n\n  sequence.on('end', function () {\n    self._dequeue(sequence);\n  });\n\n  if (this._queue.length === 1) {\n    this._parser.resetPacketNumber();\n    this._startSequence(sequence);\n  }\n\n  return sequence;\n};\n\nProtocol.prototype._validateEnqueue = function _validateEnqueue(sequence) {\n  var err;\n  var prefix = 'Cannot enqueue ' + sequence.constructor.name;\n\n  if (this._fatalError) {\n    err      = new Error(prefix + ' after fatal error.');\n    err.code = 'PROTOCOL_ENQUEUE_AFTER_FATAL_ERROR';\n  } else if (this._quitSequence) {\n    err      = new Error(prefix + ' after invoking quit.');\n    err.code = 'PROTOCOL_ENQUEUE_AFTER_QUIT';\n  } else if (this._destroyed) {\n    err      = new Error(prefix + ' after being destroyed.');\n    err.code = 'PROTOCOL_ENQUEUE_AFTER_DESTROY';\n  } else if ((this._handshake || this._handshaked) && sequence.constructor === Sequences.Handshake) {\n    err      = new Error(prefix + ' after already enqueuing a Handshake.');\n    err.code = 'PROTOCOL_ENQUEUE_HANDSHAKE_TWICE';\n  } else {\n    return true;\n  }\n\n  var self  = this;\n  err.fatal = false;\n\n  // add error handler\n  sequence.on('error', function (err) {\n    self._delegateError(err, sequence);\n  });\n\n  process.nextTick(function () {\n    sequence.end(err);\n  });\n\n  return false;\n};\n\nProtocol.prototype._parsePacket = function() {\n  var sequence = this._queue[0];\n\n  if (!sequence) {\n    var err   = new Error('Received packet with no active sequence.');\n    err.code  = 'PROTOCOL_STRAY_PACKET';\n    err.fatal = true;\n\n    this._delegateError(err);\n    return;\n  }\n\n  var Packet     = this._determinePacket(sequence);\n  var packet     = new Packet({protocol41: this._config.protocol41});\n  var packetName = Packet.name;\n\n  // Special case: Faster dispatch, and parsing done inside sequence\n  if (Packet === Packets.RowDataPacket) {\n    sequence.RowDataPacket(packet, this._parser, this._connection);\n\n    if (this._config.debug) {\n      this._debugPacket(true, packet);\n    }\n\n    return;\n  }\n\n  if (this._config.debug) {\n    this._parsePacketDebug(packet);\n  } else {\n    packet.parse(this._parser);\n  }\n\n  if (Packet === Packets.HandshakeInitializationPacket) {\n    this._handshakeInitializationPacket = packet;\n    this.emit('initialize', packet);\n  }\n\n  sequence._timer.active();\n\n  if (!sequence[packetName]) {\n    var err   = new Error('Received packet in the wrong sequence.');\n    err.code  = 'PROTOCOL_INCORRECT_PACKET_SEQUENCE';\n    err.fatal = true;\n\n    this._delegateError(err);\n    return;\n  }\n\n  sequence[packetName](packet);\n};\n\nProtocol.prototype._parsePacketDebug = function _parsePacketDebug(packet) {\n  try {\n    packet.parse(this._parser);\n  } finally {\n    this._debugPacket(true, packet);\n  }\n};\n\nProtocol.prototype._emitPacket = function(packet) {\n  var packetWriter = new PacketWriter();\n  packet.write(packetWriter);\n  this.emit('data', packetWriter.toBuffer(this._parser));\n\n  if (this._config.debug) {\n    this._debugPacket(false, packet);\n  }\n};\n\nProtocol.prototype._determinePacket = function(sequence) {\n  var firstByte = this._parser.peak();\n\n  if (sequence.determinePacket) {\n    var Packet = sequence.determinePacket(firstByte, this._parser);\n    if (Packet) {\n      return Packet;\n    }\n  }\n\n  switch (firstByte) {\n    case 0x00: return Packets.OkPacket;\n    case 0xfe: return Packets.EofPacket;\n    case 0xff: return Packets.ErrorPacket;\n  }\n\n  throw new Error('Could not determine packet, firstByte = ' + firstByte);\n};\n\nProtocol.prototype._dequeue = function(sequence) {\n  sequence._timer.stop();\n\n  // No point in advancing the queue, we are dead\n  if (this._fatalError) {\n    return;\n  }\n\n  this._queue.shift();\n\n  var sequence = this._queue[0];\n  if (!sequence) {\n    this.emit('drain');\n    return;\n  }\n\n  this._parser.resetPacketNumber();\n\n  this._startSequence(sequence);\n};\n\nProtocol.prototype._startSequence = function(sequence) {\n  if (sequence._timeout > 0 && isFinite(sequence._timeout)) {\n    sequence._timer.start(sequence._timeout);\n  }\n\n  if (sequence.constructor === Sequences.ChangeUser) {\n    sequence.start(this._handshakeInitializationPacket);\n  } else {\n    sequence.start();\n  }\n};\n\nProtocol.prototype.handleNetworkError = function(err) {\n  err.fatal = true;\n\n  var sequence = this._queue[0];\n  if (sequence) {\n    sequence.end(err);\n  } else {\n    this._delegateError(err);\n  }\n};\n\nProtocol.prototype.handleParserError = function handleParserError(err) {\n  var sequence = this._queue[0];\n  if (sequence) {\n    sequence.end(err);\n  } else {\n    this._delegateError(err);\n  }\n};\n\nProtocol.prototype._delegateError = function(err, sequence) {\n  // Stop delegating errors after the first fatal error\n  if (this._fatalError) {\n    return;\n  }\n\n  if (err.fatal) {\n    this._fatalError = err;\n  }\n\n  if (this._shouldErrorBubbleUp(err, sequence)) {\n    // Can't use regular 'error' event here as that always destroys the pipe\n    // between socket and protocol which is not what we want (unless the\n    // exception was fatal).\n    this.emit('unhandledError', err);\n  } else if (err.fatal) {\n    // Send fatal error to all sequences in the queue\n    var queue = this._queue;\n    process.nextTick(function () {\n      queue.forEach(function (sequence) {\n        sequence.end(err);\n      });\n      queue.length = 0;\n    });\n  }\n\n  // Make sure the stream we are piping to is getting closed\n  if (err.fatal) {\n    this.emit('end', err);\n  }\n};\n\nProtocol.prototype._shouldErrorBubbleUp = function(err, sequence) {\n  if (sequence) {\n    if (sequence.hasErrorHandler()) {\n      return false;\n    } else if (!err.fatal) {\n      return true;\n    }\n  }\n\n  return (err.fatal && !this._hasPendingErrorHandlers());\n};\n\nProtocol.prototype._hasPendingErrorHandlers = function() {\n  return this._queue.some(function(sequence) {\n    return sequence.hasErrorHandler();\n  });\n};\n\nProtocol.prototype.destroy = function() {\n  this._destroyed = true;\n  this._parser.pause();\n\n  if (this._connection.state !== 'disconnected') {\n    if (!this._ended) {\n      this.end();\n    }\n  }\n};\n\nProtocol.prototype._debugPacket = function(incoming, packet) {\n  var connection = this._connection;\n  var direction  = incoming\n    ? '<--'\n    : '-->';\n  var packetName = packet.constructor.name;\n  var threadId   = connection && connection.threadId !== null\n    ? ' (' + connection.threadId + ')'\n    : '';\n\n  // check for debug packet restriction\n  if (Array.isArray(this._config.debug) && this._config.debug.indexOf(packetName) === -1) {\n    return;\n  }\n\n  var packetPayload = Util.inspect(packet).replace(/^[^{]+/, '');\n\n  console.log('%s%s %s %s\\n', direction, threadId, packetName, packetPayload);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}