{"ast":null,"code":"\"use strict\";\n\nvar Buffer = require(\"safer-buffer\").Buffer;\n\n// Multibyte codec. In this scheme, a character is represented by 1 or more bytes.\n// Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.\n// To save memory and loading time, we read table files only when requested.\n\nexports._dbcs = DBCSCodec;\nvar UNASSIGNED = -1,\n  GB18030_CODE = -2,\n  SEQ_START = -10,\n  NODE_START = -1000,\n  UNASSIGNED_NODE = new Array(0x100),\n  DEF_CHAR = -1;\nfor (var i = 0; i < 0x100; i++) UNASSIGNED_NODE[i] = UNASSIGNED;\n\n// Class DBCSCodec reads and initializes mapping tables.\nfunction DBCSCodec(codecOptions, iconv) {\n  this.encodingName = codecOptions.encodingName;\n  if (!codecOptions) throw new Error(\"DBCS codec is called without the data.\");\n  if (!codecOptions.table) throw new Error(\"Encoding '\" + this.encodingName + \"' has no data.\");\n\n  // Load tables.\n  var mappingTable = codecOptions.table();\n\n  // Decode tables: MBCS -> Unicode.\n\n  // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.\n  // Trie root is decodeTables[0].\n  // Values: >=  0 -> unicode character code. can be > 0xFFFF\n  //         == UNASSIGNED -> unknown/unassigned sequence.\n  //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.\n  //         <= NODE_START -> index of the next node in our trie to process next byte.\n  //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.\n  this.decodeTables = [];\n  this.decodeTables[0] = UNASSIGNED_NODE.slice(0); // Create root node.\n\n  // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here. \n  this.decodeTableSeq = [];\n\n  // Actual mapping tables consist of chunks. Use them to fill up decode tables.\n  for (var i = 0; i < mappingTable.length; i++) this._addDecodeChunk(mappingTable[i]);\n\n  // Load & create GB18030 tables when needed.\n  if (typeof codecOptions.gb18030 === 'function') {\n    this.gb18030 = codecOptions.gb18030(); // Load GB18030 ranges.\n\n    // Add GB18030 common decode nodes.\n    var commonThirdByteNodeIdx = this.decodeTables.length;\n    this.decodeTables.push(UNASSIGNED_NODE.slice(0));\n    var commonFourthByteNodeIdx = this.decodeTables.length;\n    this.decodeTables.push(UNASSIGNED_NODE.slice(0));\n\n    // Fill out the tree\n    var firstByteNode = this.decodeTables[0];\n    for (var i = 0x81; i <= 0xFE; i++) {\n      var secondByteNode = this.decodeTables[NODE_START - firstByteNode[i]];\n      for (var j = 0x30; j <= 0x39; j++) {\n        if (secondByteNode[j] === UNASSIGNED) {\n          secondByteNode[j] = NODE_START - commonThirdByteNodeIdx;\n        } else if (secondByteNode[j] > NODE_START) {\n          throw new Error(\"gb18030 decode tables conflict at byte 2\");\n        }\n        var thirdByteNode = this.decodeTables[NODE_START - secondByteNode[j]];\n        for (var k = 0x81; k <= 0xFE; k++) {\n          if (thirdByteNode[k] === UNASSIGNED) {\n            thirdByteNode[k] = NODE_START - commonFourthByteNodeIdx;\n          } else if (thirdByteNode[k] === NODE_START - commonFourthByteNodeIdx) {\n            continue;\n          } else if (thirdByteNode[k] > NODE_START) {\n            throw new Error(\"gb18030 decode tables conflict at byte 3\");\n          }\n          var fourthByteNode = this.decodeTables[NODE_START - thirdByteNode[k]];\n          for (var l = 0x30; l <= 0x39; l++) {\n            if (fourthByteNode[l] === UNASSIGNED) fourthByteNode[l] = GB18030_CODE;\n          }\n        }\n      }\n    }\n  }\n  this.defaultCharUnicode = iconv.defaultCharUnicode;\n\n  // Encode tables: Unicode -> DBCS.\n\n  // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.\n  // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.\n  // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).\n  //         == UNASSIGNED -> no conversion found. Output a default char.\n  //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.\n  this.encodeTable = [];\n\n  // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of\n  // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key\n  // means end of sequence (needed when one sequence is a strict subsequence of another).\n  // Objects are kept separately from encodeTable to increase performance.\n  this.encodeTableSeq = [];\n\n  // Some chars can be decoded, but need not be encoded.\n  var skipEncodeChars = {};\n  if (codecOptions.encodeSkipVals) for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {\n    var val = codecOptions.encodeSkipVals[i];\n    if (typeof val === 'number') skipEncodeChars[val] = true;else for (var j = val.from; j <= val.to; j++) skipEncodeChars[j] = true;\n  }\n\n  // Use decode trie to recursively fill out encode tables.\n  this._fillEncodeTable(0, 0, skipEncodeChars);\n\n  // Add more encoding pairs when needed.\n  if (codecOptions.encodeAdd) {\n    for (var uChar in codecOptions.encodeAdd) if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar)) this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);\n  }\n  this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];\n  if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]['?'];\n  if (this.defCharSB === UNASSIGNED) this.defCharSB = \"?\".charCodeAt(0);\n}\nDBCSCodec.prototype.encoder = DBCSEncoder;\nDBCSCodec.prototype.decoder = DBCSDecoder;\n\n// Decoder helpers\nDBCSCodec.prototype._getDecodeTrieNode = function (addr) {\n  var bytes = [];\n  for (; addr > 0; addr >>>= 8) bytes.push(addr & 0xFF);\n  if (bytes.length == 0) bytes.push(0);\n  var node = this.decodeTables[0];\n  for (var i = bytes.length - 1; i > 0; i--) {\n    // Traverse nodes deeper into the trie.\n    var val = node[bytes[i]];\n    if (val == UNASSIGNED) {\n      // Create new node.\n      node[bytes[i]] = NODE_START - this.decodeTables.length;\n      this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));\n    } else if (val <= NODE_START) {\n      // Existing node.\n      node = this.decodeTables[NODE_START - val];\n    } else throw new Error(\"Overwrite byte in \" + this.encodingName + \", addr: \" + addr.toString(16));\n  }\n  return node;\n};\nDBCSCodec.prototype._addDecodeChunk = function (chunk) {\n  // First element of chunk is the hex mbcs code where we start.\n  var curAddr = parseInt(chunk[0], 16);\n\n  // Choose the decoding node where we'll write our chars.\n  var writeTable = this._getDecodeTrieNode(curAddr);\n  curAddr = curAddr & 0xFF;\n\n  // Write all other elements of the chunk to the table.\n  for (var k = 1; k < chunk.length; k++) {\n    var part = chunk[k];\n    if (typeof part === \"string\") {\n      // String, write as-is.\n      for (var l = 0; l < part.length;) {\n        var code = part.charCodeAt(l++);\n        if (0xD800 <= code && code < 0xDC00) {\n          // Decode surrogate\n          var codeTrail = part.charCodeAt(l++);\n          if (0xDC00 <= codeTrail && codeTrail < 0xE000) writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00);else throw new Error(\"Incorrect surrogate pair in \" + this.encodingName + \" at chunk \" + chunk[0]);\n        } else if (0x0FF0 < code && code <= 0x0FFF) {\n          // Character sequence (our own encoding used)\n          var len = 0xFFF - code + 2;\n          var seq = [];\n          for (var m = 0; m < len; m++) seq.push(part.charCodeAt(l++)); // Simple variation: don't support surrogates or subsequences in seq.\n\n          writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;\n          this.decodeTableSeq.push(seq);\n        } else writeTable[curAddr++] = code; // Basic char\n      }\n    } else if (typeof part === \"number\") {\n      // Integer, meaning increasing sequence starting with prev character.\n      var charCode = writeTable[curAddr - 1] + 1;\n      for (var l = 0; l < part; l++) writeTable[curAddr++] = charCode++;\n    } else throw new Error(\"Incorrect type '\" + typeof part + \"' given in \" + this.encodingName + \" at chunk \" + chunk[0]);\n  }\n  if (curAddr > 0xFF) throw new Error(\"Incorrect chunk in \" + this.encodingName + \" at addr \" + chunk[0] + \": too long\" + curAddr);\n};\n\n// Encoder helpers\nDBCSCodec.prototype._getEncodeBucket = function (uCode) {\n  var high = uCode >> 8; // This could be > 0xFF because of astral characters.\n  if (this.encodeTable[high] === undefined) this.encodeTable[high] = UNASSIGNED_NODE.slice(0); // Create bucket on demand.\n  return this.encodeTable[high];\n};\nDBCSCodec.prototype._setEncodeChar = function (uCode, dbcsCode) {\n  var bucket = this._getEncodeBucket(uCode);\n  var low = uCode & 0xFF;\n  if (bucket[low] <= SEQ_START) this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode; // There's already a sequence, set a single-char subsequence of it.\n  else if (bucket[low] == UNASSIGNED) bucket[low] = dbcsCode;\n};\nDBCSCodec.prototype._setEncodeSequence = function (seq, dbcsCode) {\n  // Get the root of character tree according to first character of the sequence.\n  var uCode = seq[0];\n  var bucket = this._getEncodeBucket(uCode);\n  var low = uCode & 0xFF;\n  var node;\n  if (bucket[low] <= SEQ_START) {\n    // There's already a sequence with  - use it.\n    node = this.encodeTableSeq[SEQ_START - bucket[low]];\n  } else {\n    // There was no sequence object - allocate a new one.\n    node = {};\n    if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low]; // If a char was set before - make it a single-char subsequence.\n    bucket[low] = SEQ_START - this.encodeTableSeq.length;\n    this.encodeTableSeq.push(node);\n  }\n\n  // Traverse the character tree, allocating new nodes as needed.\n  for (var j = 1; j < seq.length - 1; j++) {\n    var oldVal = node[uCode];\n    if (typeof oldVal === 'object') node = oldVal;else {\n      node = node[uCode] = {};\n      if (oldVal !== undefined) node[DEF_CHAR] = oldVal;\n    }\n  }\n\n  // Set the leaf to given dbcsCode.\n  uCode = seq[seq.length - 1];\n  node[uCode] = dbcsCode;\n};\nDBCSCodec.prototype._fillEncodeTable = function (nodeIdx, prefix, skipEncodeChars) {\n  var node = this.decodeTables[nodeIdx];\n  var hasValues = false;\n  var subNodeEmpty = {};\n  for (var i = 0; i < 0x100; i++) {\n    var uCode = node[i];\n    var mbCode = prefix + i;\n    if (skipEncodeChars[mbCode]) continue;\n    if (uCode >= 0) {\n      this._setEncodeChar(uCode, mbCode);\n      hasValues = true;\n    } else if (uCode <= NODE_START) {\n      var subNodeIdx = NODE_START - uCode;\n      if (!subNodeEmpty[subNodeIdx]) {\n        // Skip empty subtrees (they are too large in gb18030).\n        var newPrefix = mbCode << 8 >>> 0; // NOTE: '>>> 0' keeps 32-bit num positive.\n        if (this._fillEncodeTable(subNodeIdx, newPrefix, skipEncodeChars)) hasValues = true;else subNodeEmpty[subNodeIdx] = true;\n      }\n    } else if (uCode <= SEQ_START) {\n      this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);\n      hasValues = true;\n    }\n  }\n  return hasValues;\n};\n\n// == Encoder ==================================================================\n\nfunction DBCSEncoder(options, codec) {\n  // Encoder state\n  this.leadSurrogate = -1;\n  this.seqObj = undefined;\n\n  // Static data\n  this.encodeTable = codec.encodeTable;\n  this.encodeTableSeq = codec.encodeTableSeq;\n  this.defaultCharSingleByte = codec.defCharSB;\n  this.gb18030 = codec.gb18030;\n}\nDBCSEncoder.prototype.write = function (str) {\n  var newBuf = Buffer.alloc(str.length * (this.gb18030 ? 4 : 3)),\n    leadSurrogate = this.leadSurrogate,\n    seqObj = this.seqObj,\n    nextChar = -1,\n    i = 0,\n    j = 0;\n  while (true) {\n    // 0. Get next character.\n    if (nextChar === -1) {\n      if (i == str.length) break;\n      var uCode = str.charCodeAt(i++);\n    } else {\n      var uCode = nextChar;\n      nextChar = -1;\n    }\n\n    // 1. Handle surrogates.\n    if (0xD800 <= uCode && uCode < 0xE000) {\n      // Char is one of surrogates.\n      if (uCode < 0xDC00) {\n        // We've got lead surrogate.\n        if (leadSurrogate === -1) {\n          leadSurrogate = uCode;\n          continue;\n        } else {\n          leadSurrogate = uCode;\n          // Double lead surrogate found.\n          uCode = UNASSIGNED;\n        }\n      } else {\n        // We've got trail surrogate.\n        if (leadSurrogate !== -1) {\n          uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);\n          leadSurrogate = -1;\n        } else {\n          // Incomplete surrogate pair - only trail surrogate found.\n          uCode = UNASSIGNED;\n        }\n      }\n    } else if (leadSurrogate !== -1) {\n      // Incomplete surrogate pair - only lead surrogate found.\n      nextChar = uCode;\n      uCode = UNASSIGNED; // Write an error, then current char.\n      leadSurrogate = -1;\n    }\n\n    // 2. Convert uCode character.\n    var dbcsCode = UNASSIGNED;\n    if (seqObj !== undefined && uCode != UNASSIGNED) {\n      // We are in the middle of the sequence\n      var resCode = seqObj[uCode];\n      if (typeof resCode === 'object') {\n        // Sequence continues.\n        seqObj = resCode;\n        continue;\n      } else if (typeof resCode == 'number') {\n        // Sequence finished. Write it.\n        dbcsCode = resCode;\n      } else if (resCode == undefined) {\n        // Current character is not part of the sequence.\n\n        // Try default character for this sequence\n        resCode = seqObj[DEF_CHAR];\n        if (resCode !== undefined) {\n          dbcsCode = resCode; // Found. Write it.\n          nextChar = uCode; // Current character will be written too in the next iteration.\n        } else {\n          // TODO: What if we have no default? (resCode == undefined)\n          // Then, we should write first char of the sequence as-is and try the rest recursively.\n          // Didn't do it for now because no encoding has this situation yet.\n          // Currently, just skip the sequence and write current char.\n        }\n      }\n      seqObj = undefined;\n    } else if (uCode >= 0) {\n      // Regular character\n      var subtable = this.encodeTable[uCode >> 8];\n      if (subtable !== undefined) dbcsCode = subtable[uCode & 0xFF];\n      if (dbcsCode <= SEQ_START) {\n        // Sequence start\n        seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];\n        continue;\n      }\n      if (dbcsCode == UNASSIGNED && this.gb18030) {\n        // Use GB18030 algorithm to find character(s) to write.\n        var idx = findIdx(this.gb18030.uChars, uCode);\n        if (idx != -1) {\n          var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);\n          newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600);\n          dbcsCode = dbcsCode % 12600;\n          newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260);\n          dbcsCode = dbcsCode % 1260;\n          newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10);\n          dbcsCode = dbcsCode % 10;\n          newBuf[j++] = 0x30 + dbcsCode;\n          continue;\n        }\n      }\n    }\n\n    // 3. Write dbcsCode character.\n    if (dbcsCode === UNASSIGNED) dbcsCode = this.defaultCharSingleByte;\n    if (dbcsCode < 0x100) {\n      newBuf[j++] = dbcsCode;\n    } else if (dbcsCode < 0x10000) {\n      newBuf[j++] = dbcsCode >> 8; // high byte\n      newBuf[j++] = dbcsCode & 0xFF; // low byte\n    } else if (dbcsCode < 0x1000000) {\n      newBuf[j++] = dbcsCode >> 16;\n      newBuf[j++] = dbcsCode >> 8 & 0xFF;\n      newBuf[j++] = dbcsCode & 0xFF;\n    } else {\n      newBuf[j++] = dbcsCode >>> 24;\n      newBuf[j++] = dbcsCode >>> 16 & 0xFF;\n      newBuf[j++] = dbcsCode >>> 8 & 0xFF;\n      newBuf[j++] = dbcsCode & 0xFF;\n    }\n  }\n  this.seqObj = seqObj;\n  this.leadSurrogate = leadSurrogate;\n  return newBuf.slice(0, j);\n};\nDBCSEncoder.prototype.end = function () {\n  if (this.leadSurrogate === -1 && this.seqObj === undefined) return; // All clean. Most often case.\n\n  var newBuf = Buffer.alloc(10),\n    j = 0;\n  if (this.seqObj) {\n    // We're in the sequence.\n    var dbcsCode = this.seqObj[DEF_CHAR];\n    if (dbcsCode !== undefined) {\n      // Write beginning of the sequence.\n      if (dbcsCode < 0x100) {\n        newBuf[j++] = dbcsCode;\n      } else {\n        newBuf[j++] = dbcsCode >> 8; // high byte\n        newBuf[j++] = dbcsCode & 0xFF; // low byte\n      }\n    } else {\n      // See todo above.\n    }\n    this.seqObj = undefined;\n  }\n  if (this.leadSurrogate !== -1) {\n    // Incomplete surrogate pair - only lead surrogate found.\n    newBuf[j++] = this.defaultCharSingleByte;\n    this.leadSurrogate = -1;\n  }\n  return newBuf.slice(0, j);\n};\n\n// Export for testing\nDBCSEncoder.prototype.findIdx = findIdx;\n\n// == Decoder ==================================================================\n\nfunction DBCSDecoder(options, codec) {\n  // Decoder state\n  this.nodeIdx = 0;\n  this.prevBytes = [];\n\n  // Static data\n  this.decodeTables = codec.decodeTables;\n  this.decodeTableSeq = codec.decodeTableSeq;\n  this.defaultCharUnicode = codec.defaultCharUnicode;\n  this.gb18030 = codec.gb18030;\n}\nDBCSDecoder.prototype.write = function (buf) {\n  var newBuf = Buffer.alloc(buf.length * 2),\n    nodeIdx = this.nodeIdx,\n    prevBytes = this.prevBytes,\n    prevOffset = this.prevBytes.length,\n    seqStart = -this.prevBytes.length,\n    // idx of the start of current parsed sequence.\n    uCode;\n  for (var i = 0, j = 0; i < buf.length; i++) {\n    var curByte = i >= 0 ? buf[i] : prevBytes[i + prevOffset];\n\n    // Lookup in current trie node.\n    var uCode = this.decodeTables[nodeIdx][curByte];\n    if (uCode >= 0) {\n      // Normal character, just use it.\n    } else if (uCode === UNASSIGNED) {\n      // Unknown char.\n      // TODO: Callback with seq.\n      uCode = this.defaultCharUnicode.charCodeAt(0);\n      i = seqStart; // Skip one byte ('i' will be incremented by the for loop) and try to parse again.\n    } else if (uCode === GB18030_CODE) {\n      if (i >= 3) {\n        var ptr = (buf[i - 3] - 0x81) * 12600 + (buf[i - 2] - 0x30) * 1260 + (buf[i - 1] - 0x81) * 10 + (curByte - 0x30);\n      } else {\n        var ptr = (prevBytes[i - 3 + prevOffset] - 0x81) * 12600 + ((i - 2 >= 0 ? buf[i - 2] : prevBytes[i - 2 + prevOffset]) - 0x30) * 1260 + ((i - 1 >= 0 ? buf[i - 1] : prevBytes[i - 1 + prevOffset]) - 0x81) * 10 + (curByte - 0x30);\n      }\n      var idx = findIdx(this.gb18030.gbChars, ptr);\n      uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];\n    } else if (uCode <= NODE_START) {\n      // Go to next trie node.\n      nodeIdx = NODE_START - uCode;\n      continue;\n    } else if (uCode <= SEQ_START) {\n      // Output a sequence of chars.\n      var seq = this.decodeTableSeq[SEQ_START - uCode];\n      for (var k = 0; k < seq.length - 1; k++) {\n        uCode = seq[k];\n        newBuf[j++] = uCode & 0xFF;\n        newBuf[j++] = uCode >> 8;\n      }\n      uCode = seq[seq.length - 1];\n    } else throw new Error(\"iconv-lite internal error: invalid decoding table value \" + uCode + \" at \" + nodeIdx + \"/\" + curByte);\n\n    // Write the character to buffer, handling higher planes using surrogate pair.\n    if (uCode >= 0x10000) {\n      uCode -= 0x10000;\n      var uCodeLead = 0xD800 | uCode >> 10;\n      newBuf[j++] = uCodeLead & 0xFF;\n      newBuf[j++] = uCodeLead >> 8;\n      uCode = 0xDC00 | uCode & 0x3FF;\n    }\n    newBuf[j++] = uCode & 0xFF;\n    newBuf[j++] = uCode >> 8;\n\n    // Reset trie node.\n    nodeIdx = 0;\n    seqStart = i + 1;\n  }\n  this.nodeIdx = nodeIdx;\n  this.prevBytes = seqStart >= 0 ? Array.prototype.slice.call(buf, seqStart) : prevBytes.slice(seqStart + prevOffset).concat(Array.prototype.slice.call(buf));\n  return newBuf.slice(0, j).toString('ucs2');\n};\nDBCSDecoder.prototype.end = function () {\n  var ret = '';\n\n  // Try to parse all remaining chars.\n  while (this.prevBytes.length > 0) {\n    // Skip 1 character in the buffer.\n    ret += this.defaultCharUnicode;\n    var bytesArr = this.prevBytes.slice(1);\n\n    // Parse remaining as usual.\n    this.prevBytes = [];\n    this.nodeIdx = 0;\n    if (bytesArr.length > 0) ret += this.write(bytesArr);\n  }\n  this.prevBytes = [];\n  this.nodeIdx = 0;\n  return ret;\n};\n\n// Binary search for GB18030. Returns largest i such that table[i] <= val.\nfunction findIdx(table, val) {\n  if (table[0] > val) return -1;\n  var l = 0,\n    r = table.length;\n  while (l < r - 1) {\n    // always table[l] <= val < table[r]\n    var mid = l + (r - l + 1 >> 1);\n    if (table[mid] <= val) l = mid;else r = mid;\n  }\n  return l;\n}","map":{"version":3,"names":["Buffer","require","exports","_dbcs","DBCSCodec","UNASSIGNED","GB18030_CODE","SEQ_START","NODE_START","UNASSIGNED_NODE","Array","DEF_CHAR","i","codecOptions","iconv","encodingName","Error","table","mappingTable","decodeTables","slice","decodeTableSeq","length","_addDecodeChunk","gb18030","commonThirdByteNodeIdx","push","commonFourthByteNodeIdx","firstByteNode","secondByteNode","j","thirdByteNode","k","fourthByteNode","l","defaultCharUnicode","encodeTable","encodeTableSeq","skipEncodeChars","encodeSkipVals","val","from","to","_fillEncodeTable","encodeAdd","uChar","Object","prototype","hasOwnProperty","call","_setEncodeChar","charCodeAt","defCharSB","defaultCharSingleByte","encoder","DBCSEncoder","decoder","DBCSDecoder","_getDecodeTrieNode","addr","bytes","node","toString","chunk","curAddr","parseInt","writeTable","part","code","codeTrail","len","seq","m","charCode","_getEncodeBucket","uCode","high","undefined","dbcsCode","bucket","low","_setEncodeSequence","oldVal","nodeIdx","prefix","hasValues","subNodeEmpty","mbCode","subNodeIdx","newPrefix","options","codec","leadSurrogate","seqObj","write","str","newBuf","alloc","nextChar","resCode","subtable","idx","findIdx","uChars","gbChars","Math","floor","end","prevBytes","buf","prevOffset","seqStart","curByte","ptr","uCodeLead","concat","ret","bytesArr","r","mid"],"sources":["C:/Users/Levi/Documents/szakdoga/vizsgaremek/node_modules/iconv-lite/encodings/dbcs-codec.js"],"sourcesContent":["\"use strict\";\nvar Buffer = require(\"safer-buffer\").Buffer;\n\n// Multibyte codec. In this scheme, a character is represented by 1 or more bytes.\n// Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.\n// To save memory and loading time, we read table files only when requested.\n\nexports._dbcs = DBCSCodec;\n\nvar UNASSIGNED = -1,\n    GB18030_CODE = -2,\n    SEQ_START  = -10,\n    NODE_START = -1000,\n    UNASSIGNED_NODE = new Array(0x100),\n    DEF_CHAR = -1;\n\nfor (var i = 0; i < 0x100; i++)\n    UNASSIGNED_NODE[i] = UNASSIGNED;\n\n\n// Class DBCSCodec reads and initializes mapping tables.\nfunction DBCSCodec(codecOptions, iconv) {\n    this.encodingName = codecOptions.encodingName;\n    if (!codecOptions)\n        throw new Error(\"DBCS codec is called without the data.\")\n    if (!codecOptions.table)\n        throw new Error(\"Encoding '\" + this.encodingName + \"' has no data.\");\n\n    // Load tables.\n    var mappingTable = codecOptions.table();\n\n\n    // Decode tables: MBCS -> Unicode.\n\n    // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.\n    // Trie root is decodeTables[0].\n    // Values: >=  0 -> unicode character code. can be > 0xFFFF\n    //         == UNASSIGNED -> unknown/unassigned sequence.\n    //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.\n    //         <= NODE_START -> index of the next node in our trie to process next byte.\n    //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.\n    this.decodeTables = [];\n    this.decodeTables[0] = UNASSIGNED_NODE.slice(0); // Create root node.\n\n    // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here. \n    this.decodeTableSeq = [];\n\n    // Actual mapping tables consist of chunks. Use them to fill up decode tables.\n    for (var i = 0; i < mappingTable.length; i++)\n        this._addDecodeChunk(mappingTable[i]);\n\n    // Load & create GB18030 tables when needed.\n    if (typeof codecOptions.gb18030 === 'function') {\n        this.gb18030 = codecOptions.gb18030(); // Load GB18030 ranges.\n\n        // Add GB18030 common decode nodes.\n        var commonThirdByteNodeIdx = this.decodeTables.length;\n        this.decodeTables.push(UNASSIGNED_NODE.slice(0));\n\n        var commonFourthByteNodeIdx = this.decodeTables.length;\n        this.decodeTables.push(UNASSIGNED_NODE.slice(0));\n\n        // Fill out the tree\n        var firstByteNode = this.decodeTables[0];\n        for (var i = 0x81; i <= 0xFE; i++) {\n            var secondByteNode = this.decodeTables[NODE_START - firstByteNode[i]];\n            for (var j = 0x30; j <= 0x39; j++) {\n                if (secondByteNode[j] === UNASSIGNED) {\n                    secondByteNode[j] = NODE_START - commonThirdByteNodeIdx;\n                } else if (secondByteNode[j] > NODE_START) {\n                    throw new Error(\"gb18030 decode tables conflict at byte 2\");\n                }\n\n                var thirdByteNode = this.decodeTables[NODE_START - secondByteNode[j]];\n                for (var k = 0x81; k <= 0xFE; k++) {\n                    if (thirdByteNode[k] === UNASSIGNED) {\n                        thirdByteNode[k] = NODE_START - commonFourthByteNodeIdx;\n                    } else if (thirdByteNode[k] === NODE_START - commonFourthByteNodeIdx) {\n                        continue;\n                    } else if (thirdByteNode[k] > NODE_START) {\n                        throw new Error(\"gb18030 decode tables conflict at byte 3\");\n                    }\n\n                    var fourthByteNode = this.decodeTables[NODE_START - thirdByteNode[k]];\n                    for (var l = 0x30; l <= 0x39; l++) {\n                        if (fourthByteNode[l] === UNASSIGNED)\n                            fourthByteNode[l] = GB18030_CODE;\n                    }\n                }\n            }\n        }\n    }\n\n    this.defaultCharUnicode = iconv.defaultCharUnicode;\n\n    \n    // Encode tables: Unicode -> DBCS.\n\n    // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.\n    // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.\n    // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).\n    //         == UNASSIGNED -> no conversion found. Output a default char.\n    //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.\n    this.encodeTable = [];\n    \n    // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of\n    // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key\n    // means end of sequence (needed when one sequence is a strict subsequence of another).\n    // Objects are kept separately from encodeTable to increase performance.\n    this.encodeTableSeq = [];\n\n    // Some chars can be decoded, but need not be encoded.\n    var skipEncodeChars = {};\n    if (codecOptions.encodeSkipVals)\n        for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {\n            var val = codecOptions.encodeSkipVals[i];\n            if (typeof val === 'number')\n                skipEncodeChars[val] = true;\n            else\n                for (var j = val.from; j <= val.to; j++)\n                    skipEncodeChars[j] = true;\n        }\n        \n    // Use decode trie to recursively fill out encode tables.\n    this._fillEncodeTable(0, 0, skipEncodeChars);\n\n    // Add more encoding pairs when needed.\n    if (codecOptions.encodeAdd) {\n        for (var uChar in codecOptions.encodeAdd)\n            if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))\n                this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);\n    }\n\n    this.defCharSB  = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];\n    if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]['?'];\n    if (this.defCharSB === UNASSIGNED) this.defCharSB = \"?\".charCodeAt(0);\n}\n\nDBCSCodec.prototype.encoder = DBCSEncoder;\nDBCSCodec.prototype.decoder = DBCSDecoder;\n\n// Decoder helpers\nDBCSCodec.prototype._getDecodeTrieNode = function(addr) {\n    var bytes = [];\n    for (; addr > 0; addr >>>= 8)\n        bytes.push(addr & 0xFF);\n    if (bytes.length == 0)\n        bytes.push(0);\n\n    var node = this.decodeTables[0];\n    for (var i = bytes.length-1; i > 0; i--) { // Traverse nodes deeper into the trie.\n        var val = node[bytes[i]];\n\n        if (val == UNASSIGNED) { // Create new node.\n            node[bytes[i]] = NODE_START - this.decodeTables.length;\n            this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));\n        }\n        else if (val <= NODE_START) { // Existing node.\n            node = this.decodeTables[NODE_START - val];\n        }\n        else\n            throw new Error(\"Overwrite byte in \" + this.encodingName + \", addr: \" + addr.toString(16));\n    }\n    return node;\n}\n\n\nDBCSCodec.prototype._addDecodeChunk = function(chunk) {\n    // First element of chunk is the hex mbcs code where we start.\n    var curAddr = parseInt(chunk[0], 16);\n\n    // Choose the decoding node where we'll write our chars.\n    var writeTable = this._getDecodeTrieNode(curAddr);\n    curAddr = curAddr & 0xFF;\n\n    // Write all other elements of the chunk to the table.\n    for (var k = 1; k < chunk.length; k++) {\n        var part = chunk[k];\n        if (typeof part === \"string\") { // String, write as-is.\n            for (var l = 0; l < part.length;) {\n                var code = part.charCodeAt(l++);\n                if (0xD800 <= code && code < 0xDC00) { // Decode surrogate\n                    var codeTrail = part.charCodeAt(l++);\n                    if (0xDC00 <= codeTrail && codeTrail < 0xE000)\n                        writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00);\n                    else\n                        throw new Error(\"Incorrect surrogate pair in \"  + this.encodingName + \" at chunk \" + chunk[0]);\n                }\n                else if (0x0FF0 < code && code <= 0x0FFF) { // Character sequence (our own encoding used)\n                    var len = 0xFFF - code + 2;\n                    var seq = [];\n                    for (var m = 0; m < len; m++)\n                        seq.push(part.charCodeAt(l++)); // Simple variation: don't support surrogates or subsequences in seq.\n\n                    writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;\n                    this.decodeTableSeq.push(seq);\n                }\n                else\n                    writeTable[curAddr++] = code; // Basic char\n            }\n        } \n        else if (typeof part === \"number\") { // Integer, meaning increasing sequence starting with prev character.\n            var charCode = writeTable[curAddr - 1] + 1;\n            for (var l = 0; l < part; l++)\n                writeTable[curAddr++] = charCode++;\n        }\n        else\n            throw new Error(\"Incorrect type '\" + typeof part + \"' given in \"  + this.encodingName + \" at chunk \" + chunk[0]);\n    }\n    if (curAddr > 0xFF)\n        throw new Error(\"Incorrect chunk in \"  + this.encodingName + \" at addr \" + chunk[0] + \": too long\" + curAddr);\n}\n\n// Encoder helpers\nDBCSCodec.prototype._getEncodeBucket = function(uCode) {\n    var high = uCode >> 8; // This could be > 0xFF because of astral characters.\n    if (this.encodeTable[high] === undefined)\n        this.encodeTable[high] = UNASSIGNED_NODE.slice(0); // Create bucket on demand.\n    return this.encodeTable[high];\n}\n\nDBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {\n    var bucket = this._getEncodeBucket(uCode);\n    var low = uCode & 0xFF;\n    if (bucket[low] <= SEQ_START)\n        this.encodeTableSeq[SEQ_START-bucket[low]][DEF_CHAR] = dbcsCode; // There's already a sequence, set a single-char subsequence of it.\n    else if (bucket[low] == UNASSIGNED)\n        bucket[low] = dbcsCode;\n}\n\nDBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {\n    \n    // Get the root of character tree according to first character of the sequence.\n    var uCode = seq[0];\n    var bucket = this._getEncodeBucket(uCode);\n    var low = uCode & 0xFF;\n\n    var node;\n    if (bucket[low] <= SEQ_START) {\n        // There's already a sequence with  - use it.\n        node = this.encodeTableSeq[SEQ_START-bucket[low]];\n    }\n    else {\n        // There was no sequence object - allocate a new one.\n        node = {};\n        if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low]; // If a char was set before - make it a single-char subsequence.\n        bucket[low] = SEQ_START - this.encodeTableSeq.length;\n        this.encodeTableSeq.push(node);\n    }\n\n    // Traverse the character tree, allocating new nodes as needed.\n    for (var j = 1; j < seq.length-1; j++) {\n        var oldVal = node[uCode];\n        if (typeof oldVal === 'object')\n            node = oldVal;\n        else {\n            node = node[uCode] = {}\n            if (oldVal !== undefined)\n                node[DEF_CHAR] = oldVal\n        }\n    }\n\n    // Set the leaf to given dbcsCode.\n    uCode = seq[seq.length-1];\n    node[uCode] = dbcsCode;\n}\n\nDBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {\n    var node = this.decodeTables[nodeIdx];\n    var hasValues = false;\n    var subNodeEmpty = {};\n    for (var i = 0; i < 0x100; i++) {\n        var uCode = node[i];\n        var mbCode = prefix + i;\n        if (skipEncodeChars[mbCode])\n            continue;\n\n        if (uCode >= 0) {\n            this._setEncodeChar(uCode, mbCode);\n            hasValues = true;\n        } else if (uCode <= NODE_START) {\n            var subNodeIdx = NODE_START - uCode;\n            if (!subNodeEmpty[subNodeIdx]) {  // Skip empty subtrees (they are too large in gb18030).\n                var newPrefix = (mbCode << 8) >>> 0;  // NOTE: '>>> 0' keeps 32-bit num positive.\n                if (this._fillEncodeTable(subNodeIdx, newPrefix, skipEncodeChars))\n                    hasValues = true;\n                else\n                    subNodeEmpty[subNodeIdx] = true;\n            }\n        } else if (uCode <= SEQ_START) {\n            this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);\n            hasValues = true;\n        }\n    }\n    return hasValues;\n}\n\n\n\n// == Encoder ==================================================================\n\nfunction DBCSEncoder(options, codec) {\n    // Encoder state\n    this.leadSurrogate = -1;\n    this.seqObj = undefined;\n    \n    // Static data\n    this.encodeTable = codec.encodeTable;\n    this.encodeTableSeq = codec.encodeTableSeq;\n    this.defaultCharSingleByte = codec.defCharSB;\n    this.gb18030 = codec.gb18030;\n}\n\nDBCSEncoder.prototype.write = function(str) {\n    var newBuf = Buffer.alloc(str.length * (this.gb18030 ? 4 : 3)),\n        leadSurrogate = this.leadSurrogate,\n        seqObj = this.seqObj, nextChar = -1,\n        i = 0, j = 0;\n\n    while (true) {\n        // 0. Get next character.\n        if (nextChar === -1) {\n            if (i == str.length) break;\n            var uCode = str.charCodeAt(i++);\n        }\n        else {\n            var uCode = nextChar;\n            nextChar = -1;    \n        }\n\n        // 1. Handle surrogates.\n        if (0xD800 <= uCode && uCode < 0xE000) { // Char is one of surrogates.\n            if (uCode < 0xDC00) { // We've got lead surrogate.\n                if (leadSurrogate === -1) {\n                    leadSurrogate = uCode;\n                    continue;\n                } else {\n                    leadSurrogate = uCode;\n                    // Double lead surrogate found.\n                    uCode = UNASSIGNED;\n                }\n            } else { // We've got trail surrogate.\n                if (leadSurrogate !== -1) {\n                    uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);\n                    leadSurrogate = -1;\n                } else {\n                    // Incomplete surrogate pair - only trail surrogate found.\n                    uCode = UNASSIGNED;\n                }\n                \n            }\n        }\n        else if (leadSurrogate !== -1) {\n            // Incomplete surrogate pair - only lead surrogate found.\n            nextChar = uCode; uCode = UNASSIGNED; // Write an error, then current char.\n            leadSurrogate = -1;\n        }\n\n        // 2. Convert uCode character.\n        var dbcsCode = UNASSIGNED;\n        if (seqObj !== undefined && uCode != UNASSIGNED) { // We are in the middle of the sequence\n            var resCode = seqObj[uCode];\n            if (typeof resCode === 'object') { // Sequence continues.\n                seqObj = resCode;\n                continue;\n\n            } else if (typeof resCode == 'number') { // Sequence finished. Write it.\n                dbcsCode = resCode;\n\n            } else if (resCode == undefined) { // Current character is not part of the sequence.\n\n                // Try default character for this sequence\n                resCode = seqObj[DEF_CHAR];\n                if (resCode !== undefined) {\n                    dbcsCode = resCode; // Found. Write it.\n                    nextChar = uCode; // Current character will be written too in the next iteration.\n\n                } else {\n                    // TODO: What if we have no default? (resCode == undefined)\n                    // Then, we should write first char of the sequence as-is and try the rest recursively.\n                    // Didn't do it for now because no encoding has this situation yet.\n                    // Currently, just skip the sequence and write current char.\n                }\n            }\n            seqObj = undefined;\n        }\n        else if (uCode >= 0) {  // Regular character\n            var subtable = this.encodeTable[uCode >> 8];\n            if (subtable !== undefined)\n                dbcsCode = subtable[uCode & 0xFF];\n            \n            if (dbcsCode <= SEQ_START) { // Sequence start\n                seqObj = this.encodeTableSeq[SEQ_START-dbcsCode];\n                continue;\n            }\n\n            if (dbcsCode == UNASSIGNED && this.gb18030) {\n                // Use GB18030 algorithm to find character(s) to write.\n                var idx = findIdx(this.gb18030.uChars, uCode);\n                if (idx != -1) {\n                    var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);\n                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600); dbcsCode = dbcsCode % 12600;\n                    newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260); dbcsCode = dbcsCode % 1260;\n                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10); dbcsCode = dbcsCode % 10;\n                    newBuf[j++] = 0x30 + dbcsCode;\n                    continue;\n                }\n            }\n        }\n\n        // 3. Write dbcsCode character.\n        if (dbcsCode === UNASSIGNED)\n            dbcsCode = this.defaultCharSingleByte;\n        \n        if (dbcsCode < 0x100) {\n            newBuf[j++] = dbcsCode;\n        }\n        else if (dbcsCode < 0x10000) {\n            newBuf[j++] = dbcsCode >> 8;   // high byte\n            newBuf[j++] = dbcsCode & 0xFF; // low byte\n        }\n        else if (dbcsCode < 0x1000000) {\n            newBuf[j++] = dbcsCode >> 16;\n            newBuf[j++] = (dbcsCode >> 8) & 0xFF;\n            newBuf[j++] = dbcsCode & 0xFF;\n        } else {\n            newBuf[j++] = dbcsCode >>> 24;\n            newBuf[j++] = (dbcsCode >>> 16) & 0xFF;\n            newBuf[j++] = (dbcsCode >>> 8) & 0xFF;\n            newBuf[j++] = dbcsCode & 0xFF;\n        }\n    }\n\n    this.seqObj = seqObj;\n    this.leadSurrogate = leadSurrogate;\n    return newBuf.slice(0, j);\n}\n\nDBCSEncoder.prototype.end = function() {\n    if (this.leadSurrogate === -1 && this.seqObj === undefined)\n        return; // All clean. Most often case.\n\n    var newBuf = Buffer.alloc(10), j = 0;\n\n    if (this.seqObj) { // We're in the sequence.\n        var dbcsCode = this.seqObj[DEF_CHAR];\n        if (dbcsCode !== undefined) { // Write beginning of the sequence.\n            if (dbcsCode < 0x100) {\n                newBuf[j++] = dbcsCode;\n            }\n            else {\n                newBuf[j++] = dbcsCode >> 8;   // high byte\n                newBuf[j++] = dbcsCode & 0xFF; // low byte\n            }\n        } else {\n            // See todo above.\n        }\n        this.seqObj = undefined;\n    }\n\n    if (this.leadSurrogate !== -1) {\n        // Incomplete surrogate pair - only lead surrogate found.\n        newBuf[j++] = this.defaultCharSingleByte;\n        this.leadSurrogate = -1;\n    }\n    \n    return newBuf.slice(0, j);\n}\n\n// Export for testing\nDBCSEncoder.prototype.findIdx = findIdx;\n\n\n// == Decoder ==================================================================\n\nfunction DBCSDecoder(options, codec) {\n    // Decoder state\n    this.nodeIdx = 0;\n    this.prevBytes = [];\n\n    // Static data\n    this.decodeTables = codec.decodeTables;\n    this.decodeTableSeq = codec.decodeTableSeq;\n    this.defaultCharUnicode = codec.defaultCharUnicode;\n    this.gb18030 = codec.gb18030;\n}\n\nDBCSDecoder.prototype.write = function(buf) {\n    var newBuf = Buffer.alloc(buf.length*2),\n        nodeIdx = this.nodeIdx, \n        prevBytes = this.prevBytes, prevOffset = this.prevBytes.length,\n        seqStart = -this.prevBytes.length, // idx of the start of current parsed sequence.\n        uCode;\n\n    for (var i = 0, j = 0; i < buf.length; i++) {\n        var curByte = (i >= 0) ? buf[i] : prevBytes[i + prevOffset];\n\n        // Lookup in current trie node.\n        var uCode = this.decodeTables[nodeIdx][curByte];\n\n        if (uCode >= 0) { \n            // Normal character, just use it.\n        }\n        else if (uCode === UNASSIGNED) { // Unknown char.\n            // TODO: Callback with seq.\n            uCode = this.defaultCharUnicode.charCodeAt(0);\n            i = seqStart; // Skip one byte ('i' will be incremented by the for loop) and try to parse again.\n        }\n        else if (uCode === GB18030_CODE) {\n            if (i >= 3) {\n                var ptr = (buf[i-3]-0x81)*12600 + (buf[i-2]-0x30)*1260 + (buf[i-1]-0x81)*10 + (curByte-0x30);\n            } else {\n                var ptr = (prevBytes[i-3+prevOffset]-0x81)*12600 + \n                          (((i-2 >= 0) ? buf[i-2] : prevBytes[i-2+prevOffset])-0x30)*1260 + \n                          (((i-1 >= 0) ? buf[i-1] : prevBytes[i-1+prevOffset])-0x81)*10 + \n                          (curByte-0x30);\n            }\n            var idx = findIdx(this.gb18030.gbChars, ptr);\n            uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];\n        }\n        else if (uCode <= NODE_START) { // Go to next trie node.\n            nodeIdx = NODE_START - uCode;\n            continue;\n        }\n        else if (uCode <= SEQ_START) { // Output a sequence of chars.\n            var seq = this.decodeTableSeq[SEQ_START - uCode];\n            for (var k = 0; k < seq.length - 1; k++) {\n                uCode = seq[k];\n                newBuf[j++] = uCode & 0xFF;\n                newBuf[j++] = uCode >> 8;\n            }\n            uCode = seq[seq.length-1];\n        }\n        else\n            throw new Error(\"iconv-lite internal error: invalid decoding table value \" + uCode + \" at \" + nodeIdx + \"/\" + curByte);\n\n        // Write the character to buffer, handling higher planes using surrogate pair.\n        if (uCode >= 0x10000) { \n            uCode -= 0x10000;\n            var uCodeLead = 0xD800 | (uCode >> 10);\n            newBuf[j++] = uCodeLead & 0xFF;\n            newBuf[j++] = uCodeLead >> 8;\n\n            uCode = 0xDC00 | (uCode & 0x3FF);\n        }\n        newBuf[j++] = uCode & 0xFF;\n        newBuf[j++] = uCode >> 8;\n\n        // Reset trie node.\n        nodeIdx = 0; seqStart = i+1;\n    }\n\n    this.nodeIdx = nodeIdx;\n    this.prevBytes = (seqStart >= 0)\n        ? Array.prototype.slice.call(buf, seqStart)\n        : prevBytes.slice(seqStart + prevOffset).concat(Array.prototype.slice.call(buf));\n\n    return newBuf.slice(0, j).toString('ucs2');\n}\n\nDBCSDecoder.prototype.end = function() {\n    var ret = '';\n\n    // Try to parse all remaining chars.\n    while (this.prevBytes.length > 0) {\n        // Skip 1 character in the buffer.\n        ret += this.defaultCharUnicode;\n        var bytesArr = this.prevBytes.slice(1);\n\n        // Parse remaining as usual.\n        this.prevBytes = [];\n        this.nodeIdx = 0;\n        if (bytesArr.length > 0)\n            ret += this.write(bytesArr);\n    }\n\n    this.prevBytes = [];\n    this.nodeIdx = 0;\n    return ret;\n}\n\n// Binary search for GB18030. Returns largest i such that table[i] <= val.\nfunction findIdx(table, val) {\n    if (table[0] > val)\n        return -1;\n\n    var l = 0, r = table.length;\n    while (l < r-1) { // always table[l] <= val < table[r]\n        var mid = l + ((r-l+1) >> 1);\n        if (table[mid] <= val)\n            l = mid;\n        else\n            r = mid;\n    }\n    return l;\n}\n\n"],"mappings":"AAAA,YAAY;;AACZ,IAAIA,MAAM,GAAGC,OAAO,CAAC,cAAc,CAAC,CAACD,MAAM;;AAE3C;AACA;AACA;;AAEAE,OAAO,CAACC,KAAK,GAAGC,SAAS;AAEzB,IAAIC,UAAU,GAAG,CAAC,CAAC;EACfC,YAAY,GAAG,CAAC,CAAC;EACjBC,SAAS,GAAI,CAAC,EAAE;EAChBC,UAAU,GAAG,CAAC,IAAI;EAClBC,eAAe,GAAG,IAAIC,KAAK,CAAC,KAAK,CAAC;EAClCC,QAAQ,GAAG,CAAC,CAAC;AAEjB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,KAAK,EAAEA,CAAC,EAAE,EAC1BH,eAAe,CAACG,CAAC,CAAC,GAAGP,UAAU;;AAGnC;AACA,SAASD,SAASA,CAACS,YAAY,EAAEC,KAAK,EAAE;EACpC,IAAI,CAACC,YAAY,GAAGF,YAAY,CAACE,YAAY;EAC7C,IAAI,CAACF,YAAY,EACb,MAAM,IAAIG,KAAK,CAAC,wCAAwC,CAAC;EAC7D,IAAI,CAACH,YAAY,CAACI,KAAK,EACnB,MAAM,IAAID,KAAK,CAAC,YAAY,GAAG,IAAI,CAACD,YAAY,GAAG,gBAAgB,CAAC;;EAExE;EACA,IAAIG,YAAY,GAAGL,YAAY,CAACI,KAAK,CAAC,CAAC;;EAGvC;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,IAAI,CAACE,YAAY,GAAG,EAAE;EACtB,IAAI,CAACA,YAAY,CAAC,CAAC,CAAC,GAAGV,eAAe,CAACW,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;;EAEjD;EACA,IAAI,CAACC,cAAc,GAAG,EAAE;;EAExB;EACA,KAAK,IAAIT,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGM,YAAY,CAACI,MAAM,EAAEV,CAAC,EAAE,EACxC,IAAI,CAACW,eAAe,CAACL,YAAY,CAACN,CAAC,CAAC,CAAC;;EAEzC;EACA,IAAI,OAAOC,YAAY,CAACW,OAAO,KAAK,UAAU,EAAE;IAC5C,IAAI,CAACA,OAAO,GAAGX,YAAY,CAACW,OAAO,CAAC,CAAC,CAAC,CAAC;;IAEvC;IACA,IAAIC,sBAAsB,GAAG,IAAI,CAACN,YAAY,CAACG,MAAM;IACrD,IAAI,CAACH,YAAY,CAACO,IAAI,CAACjB,eAAe,CAACW,KAAK,CAAC,CAAC,CAAC,CAAC;IAEhD,IAAIO,uBAAuB,GAAG,IAAI,CAACR,YAAY,CAACG,MAAM;IACtD,IAAI,CAACH,YAAY,CAACO,IAAI,CAACjB,eAAe,CAACW,KAAK,CAAC,CAAC,CAAC,CAAC;;IAEhD;IACA,IAAIQ,aAAa,GAAG,IAAI,CAACT,YAAY,CAAC,CAAC,CAAC;IACxC,KAAK,IAAIP,CAAC,GAAG,IAAI,EAAEA,CAAC,IAAI,IAAI,EAAEA,CAAC,EAAE,EAAE;MAC/B,IAAIiB,cAAc,GAAG,IAAI,CAACV,YAAY,CAACX,UAAU,GAAGoB,aAAa,CAAChB,CAAC,CAAC,CAAC;MACrE,KAAK,IAAIkB,CAAC,GAAG,IAAI,EAAEA,CAAC,IAAI,IAAI,EAAEA,CAAC,EAAE,EAAE;QAC/B,IAAID,cAAc,CAACC,CAAC,CAAC,KAAKzB,UAAU,EAAE;UAClCwB,cAAc,CAACC,CAAC,CAAC,GAAGtB,UAAU,GAAGiB,sBAAsB;QAC3D,CAAC,MAAM,IAAII,cAAc,CAACC,CAAC,CAAC,GAAGtB,UAAU,EAAE;UACvC,MAAM,IAAIQ,KAAK,CAAC,0CAA0C,CAAC;QAC/D;QAEA,IAAIe,aAAa,GAAG,IAAI,CAACZ,YAAY,CAACX,UAAU,GAAGqB,cAAc,CAACC,CAAC,CAAC,CAAC;QACrE,KAAK,IAAIE,CAAC,GAAG,IAAI,EAAEA,CAAC,IAAI,IAAI,EAAEA,CAAC,EAAE,EAAE;UAC/B,IAAID,aAAa,CAACC,CAAC,CAAC,KAAK3B,UAAU,EAAE;YACjC0B,aAAa,CAACC,CAAC,CAAC,GAAGxB,UAAU,GAAGmB,uBAAuB;UAC3D,CAAC,MAAM,IAAII,aAAa,CAACC,CAAC,CAAC,KAAKxB,UAAU,GAAGmB,uBAAuB,EAAE;YAClE;UACJ,CAAC,MAAM,IAAII,aAAa,CAACC,CAAC,CAAC,GAAGxB,UAAU,EAAE;YACtC,MAAM,IAAIQ,KAAK,CAAC,0CAA0C,CAAC;UAC/D;UAEA,IAAIiB,cAAc,GAAG,IAAI,CAACd,YAAY,CAACX,UAAU,GAAGuB,aAAa,CAACC,CAAC,CAAC,CAAC;UACrE,KAAK,IAAIE,CAAC,GAAG,IAAI,EAAEA,CAAC,IAAI,IAAI,EAAEA,CAAC,EAAE,EAAE;YAC/B,IAAID,cAAc,CAACC,CAAC,CAAC,KAAK7B,UAAU,EAChC4B,cAAc,CAACC,CAAC,CAAC,GAAG5B,YAAY;UACxC;QACJ;MACJ;IACJ;EACJ;EAEA,IAAI,CAAC6B,kBAAkB,GAAGrB,KAAK,CAACqB,kBAAkB;;EAGlD;;EAEA;EACA;EACA;EACA;EACA;EACA,IAAI,CAACC,WAAW,GAAG,EAAE;;EAErB;EACA;EACA;EACA;EACA,IAAI,CAACC,cAAc,GAAG,EAAE;;EAExB;EACA,IAAIC,eAAe,GAAG,CAAC,CAAC;EACxB,IAAIzB,YAAY,CAAC0B,cAAc,EAC3B,KAAK,IAAI3B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGC,YAAY,CAAC0B,cAAc,CAACjB,MAAM,EAAEV,CAAC,EAAE,EAAE;IACzD,IAAI4B,GAAG,GAAG3B,YAAY,CAAC0B,cAAc,CAAC3B,CAAC,CAAC;IACxC,IAAI,OAAO4B,GAAG,KAAK,QAAQ,EACvBF,eAAe,CAACE,GAAG,CAAC,GAAG,IAAI,CAAC,KAE5B,KAAK,IAAIV,CAAC,GAAGU,GAAG,CAACC,IAAI,EAAEX,CAAC,IAAIU,GAAG,CAACE,EAAE,EAAEZ,CAAC,EAAE,EACnCQ,eAAe,CAACR,CAAC,CAAC,GAAG,IAAI;EACrC;;EAEJ;EACA,IAAI,CAACa,gBAAgB,CAAC,CAAC,EAAE,CAAC,EAAEL,eAAe,CAAC;;EAE5C;EACA,IAAIzB,YAAY,CAAC+B,SAAS,EAAE;IACxB,KAAK,IAAIC,KAAK,IAAIhC,YAAY,CAAC+B,SAAS,EACpC,IAAIE,MAAM,CAACC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACpC,YAAY,CAAC+B,SAAS,EAAEC,KAAK,CAAC,EACnE,IAAI,CAACK,cAAc,CAACL,KAAK,CAACM,UAAU,CAAC,CAAC,CAAC,EAAEtC,YAAY,CAAC+B,SAAS,CAACC,KAAK,CAAC,CAAC;EACnF;EAEA,IAAI,CAACO,SAAS,GAAI,IAAI,CAAChB,WAAW,CAAC,CAAC,CAAC,CAACtB,KAAK,CAACuC,qBAAqB,CAACF,UAAU,CAAC,CAAC,CAAC,CAAC;EAChF,IAAI,IAAI,CAACC,SAAS,KAAK/C,UAAU,EAAE,IAAI,CAAC+C,SAAS,GAAG,IAAI,CAAChB,WAAW,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;EAC5E,IAAI,IAAI,CAACgB,SAAS,KAAK/C,UAAU,EAAE,IAAI,CAAC+C,SAAS,GAAG,GAAG,CAACD,UAAU,CAAC,CAAC,CAAC;AACzE;AAEA/C,SAAS,CAAC2C,SAAS,CAACO,OAAO,GAAGC,WAAW;AACzCnD,SAAS,CAAC2C,SAAS,CAACS,OAAO,GAAGC,WAAW;;AAEzC;AACArD,SAAS,CAAC2C,SAAS,CAACW,kBAAkB,GAAG,UAASC,IAAI,EAAE;EACpD,IAAIC,KAAK,GAAG,EAAE;EACd,OAAOD,IAAI,GAAG,CAAC,EAAEA,IAAI,MAAM,CAAC,EACxBC,KAAK,CAAClC,IAAI,CAACiC,IAAI,GAAG,IAAI,CAAC;EAC3B,IAAIC,KAAK,CAACtC,MAAM,IAAI,CAAC,EACjBsC,KAAK,CAAClC,IAAI,CAAC,CAAC,CAAC;EAEjB,IAAImC,IAAI,GAAG,IAAI,CAAC1C,YAAY,CAAC,CAAC,CAAC;EAC/B,KAAK,IAAIP,CAAC,GAAGgD,KAAK,CAACtC,MAAM,GAAC,CAAC,EAAEV,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;IAAE;IACvC,IAAI4B,GAAG,GAAGqB,IAAI,CAACD,KAAK,CAAChD,CAAC,CAAC,CAAC;IAExB,IAAI4B,GAAG,IAAInC,UAAU,EAAE;MAAE;MACrBwD,IAAI,CAACD,KAAK,CAAChD,CAAC,CAAC,CAAC,GAAGJ,UAAU,GAAG,IAAI,CAACW,YAAY,CAACG,MAAM;MACtD,IAAI,CAACH,YAAY,CAACO,IAAI,CAACmC,IAAI,GAAGpD,eAAe,CAACW,KAAK,CAAC,CAAC,CAAC,CAAC;IAC3D,CAAC,MACI,IAAIoB,GAAG,IAAIhC,UAAU,EAAE;MAAE;MAC1BqD,IAAI,GAAG,IAAI,CAAC1C,YAAY,CAACX,UAAU,GAAGgC,GAAG,CAAC;IAC9C,CAAC,MAEG,MAAM,IAAIxB,KAAK,CAAC,oBAAoB,GAAG,IAAI,CAACD,YAAY,GAAG,UAAU,GAAG4C,IAAI,CAACG,QAAQ,CAAC,EAAE,CAAC,CAAC;EAClG;EACA,OAAOD,IAAI;AACf,CAAC;AAGDzD,SAAS,CAAC2C,SAAS,CAACxB,eAAe,GAAG,UAASwC,KAAK,EAAE;EAClD;EACA,IAAIC,OAAO,GAAGC,QAAQ,CAACF,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;;EAEpC;EACA,IAAIG,UAAU,GAAG,IAAI,CAACR,kBAAkB,CAACM,OAAO,CAAC;EACjDA,OAAO,GAAGA,OAAO,GAAG,IAAI;;EAExB;EACA,KAAK,IAAIhC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+B,KAAK,CAACzC,MAAM,EAAEU,CAAC,EAAE,EAAE;IACnC,IAAImC,IAAI,GAAGJ,KAAK,CAAC/B,CAAC,CAAC;IACnB,IAAI,OAAOmC,IAAI,KAAK,QAAQ,EAAE;MAAE;MAC5B,KAAK,IAAIjC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiC,IAAI,CAAC7C,MAAM,GAAG;QAC9B,IAAI8C,IAAI,GAAGD,IAAI,CAAChB,UAAU,CAACjB,CAAC,EAAE,CAAC;QAC/B,IAAI,MAAM,IAAIkC,IAAI,IAAIA,IAAI,GAAG,MAAM,EAAE;UAAE;UACnC,IAAIC,SAAS,GAAGF,IAAI,CAAChB,UAAU,CAACjB,CAAC,EAAE,CAAC;UACpC,IAAI,MAAM,IAAImC,SAAS,IAAIA,SAAS,GAAG,MAAM,EACzCH,UAAU,CAACF,OAAO,EAAE,CAAC,GAAG,OAAO,GAAG,CAACI,IAAI,GAAG,MAAM,IAAI,KAAK,IAAIC,SAAS,GAAG,MAAM,CAAC,CAAC,KAEjF,MAAM,IAAIrD,KAAK,CAAC,8BAA8B,GAAI,IAAI,CAACD,YAAY,GAAG,YAAY,GAAGgD,KAAK,CAAC,CAAC,CAAC,CAAC;QACtG,CAAC,MACI,IAAI,MAAM,GAAGK,IAAI,IAAIA,IAAI,IAAI,MAAM,EAAE;UAAE;UACxC,IAAIE,GAAG,GAAG,KAAK,GAAGF,IAAI,GAAG,CAAC;UAC1B,IAAIG,GAAG,GAAG,EAAE;UACZ,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,GAAG,EAAEE,CAAC,EAAE,EACxBD,GAAG,CAAC7C,IAAI,CAACyC,IAAI,CAAChB,UAAU,CAACjB,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;;UAEpCgC,UAAU,CAACF,OAAO,EAAE,CAAC,GAAGzD,SAAS,GAAG,IAAI,CAACc,cAAc,CAACC,MAAM;UAC9D,IAAI,CAACD,cAAc,CAACK,IAAI,CAAC6C,GAAG,CAAC;QACjC,CAAC,MAEGL,UAAU,CAACF,OAAO,EAAE,CAAC,GAAGI,IAAI,CAAC,CAAC;MACtC;IACJ,CAAC,MACI,IAAI,OAAOD,IAAI,KAAK,QAAQ,EAAE;MAAE;MACjC,IAAIM,QAAQ,GAAGP,UAAU,CAACF,OAAO,GAAG,CAAC,CAAC,GAAG,CAAC;MAC1C,KAAK,IAAI9B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiC,IAAI,EAAEjC,CAAC,EAAE,EACzBgC,UAAU,CAACF,OAAO,EAAE,CAAC,GAAGS,QAAQ,EAAE;IAC1C,CAAC,MAEG,MAAM,IAAIzD,KAAK,CAAC,kBAAkB,GAAG,OAAOmD,IAAI,GAAG,aAAa,GAAI,IAAI,CAACpD,YAAY,GAAG,YAAY,GAAGgD,KAAK,CAAC,CAAC,CAAC,CAAC;EACxH;EACA,IAAIC,OAAO,GAAG,IAAI,EACd,MAAM,IAAIhD,KAAK,CAAC,qBAAqB,GAAI,IAAI,CAACD,YAAY,GAAG,WAAW,GAAGgD,KAAK,CAAC,CAAC,CAAC,GAAG,YAAY,GAAGC,OAAO,CAAC;AACrH,CAAC;;AAED;AACA5D,SAAS,CAAC2C,SAAS,CAAC2B,gBAAgB,GAAG,UAASC,KAAK,EAAE;EACnD,IAAIC,IAAI,GAAGD,KAAK,IAAI,CAAC,CAAC,CAAC;EACvB,IAAI,IAAI,CAACvC,WAAW,CAACwC,IAAI,CAAC,KAAKC,SAAS,EACpC,IAAI,CAACzC,WAAW,CAACwC,IAAI,CAAC,GAAGnE,eAAe,CAACW,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;EACvD,OAAO,IAAI,CAACgB,WAAW,CAACwC,IAAI,CAAC;AACjC,CAAC;AAEDxE,SAAS,CAAC2C,SAAS,CAACG,cAAc,GAAG,UAASyB,KAAK,EAAEG,QAAQ,EAAE;EAC3D,IAAIC,MAAM,GAAG,IAAI,CAACL,gBAAgB,CAACC,KAAK,CAAC;EACzC,IAAIK,GAAG,GAAGL,KAAK,GAAG,IAAI;EACtB,IAAII,MAAM,CAACC,GAAG,CAAC,IAAIzE,SAAS,EACxB,IAAI,CAAC8B,cAAc,CAAC9B,SAAS,GAACwE,MAAM,CAACC,GAAG,CAAC,CAAC,CAACrE,QAAQ,CAAC,GAAGmE,QAAQ,CAAC,CAAC;EAAA,KAChE,IAAIC,MAAM,CAACC,GAAG,CAAC,IAAI3E,UAAU,EAC9B0E,MAAM,CAACC,GAAG,CAAC,GAAGF,QAAQ;AAC9B,CAAC;AAED1E,SAAS,CAAC2C,SAAS,CAACkC,kBAAkB,GAAG,UAASV,GAAG,EAAEO,QAAQ,EAAE;EAE7D;EACA,IAAIH,KAAK,GAAGJ,GAAG,CAAC,CAAC,CAAC;EAClB,IAAIQ,MAAM,GAAG,IAAI,CAACL,gBAAgB,CAACC,KAAK,CAAC;EACzC,IAAIK,GAAG,GAAGL,KAAK,GAAG,IAAI;EAEtB,IAAId,IAAI;EACR,IAAIkB,MAAM,CAACC,GAAG,CAAC,IAAIzE,SAAS,EAAE;IAC1B;IACAsD,IAAI,GAAG,IAAI,CAACxB,cAAc,CAAC9B,SAAS,GAACwE,MAAM,CAACC,GAAG,CAAC,CAAC;EACrD,CAAC,MACI;IACD;IACAnB,IAAI,GAAG,CAAC,CAAC;IACT,IAAIkB,MAAM,CAACC,GAAG,CAAC,KAAK3E,UAAU,EAAEwD,IAAI,CAAClD,QAAQ,CAAC,GAAGoE,MAAM,CAACC,GAAG,CAAC,CAAC,CAAC;IAC9DD,MAAM,CAACC,GAAG,CAAC,GAAGzE,SAAS,GAAG,IAAI,CAAC8B,cAAc,CAACf,MAAM;IACpD,IAAI,CAACe,cAAc,CAACX,IAAI,CAACmC,IAAI,CAAC;EAClC;;EAEA;EACA,KAAK,IAAI/B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyC,GAAG,CAACjD,MAAM,GAAC,CAAC,EAAEQ,CAAC,EAAE,EAAE;IACnC,IAAIoD,MAAM,GAAGrB,IAAI,CAACc,KAAK,CAAC;IACxB,IAAI,OAAOO,MAAM,KAAK,QAAQ,EAC1BrB,IAAI,GAAGqB,MAAM,CAAC,KACb;MACDrB,IAAI,GAAGA,IAAI,CAACc,KAAK,CAAC,GAAG,CAAC,CAAC;MACvB,IAAIO,MAAM,KAAKL,SAAS,EACpBhB,IAAI,CAAClD,QAAQ,CAAC,GAAGuE,MAAM;IAC/B;EACJ;;EAEA;EACAP,KAAK,GAAGJ,GAAG,CAACA,GAAG,CAACjD,MAAM,GAAC,CAAC,CAAC;EACzBuC,IAAI,CAACc,KAAK,CAAC,GAAGG,QAAQ;AAC1B,CAAC;AAED1E,SAAS,CAAC2C,SAAS,CAACJ,gBAAgB,GAAG,UAASwC,OAAO,EAAEC,MAAM,EAAE9C,eAAe,EAAE;EAC9E,IAAIuB,IAAI,GAAG,IAAI,CAAC1C,YAAY,CAACgE,OAAO,CAAC;EACrC,IAAIE,SAAS,GAAG,KAAK;EACrB,IAAIC,YAAY,GAAG,CAAC,CAAC;EACrB,KAAK,IAAI1E,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,KAAK,EAAEA,CAAC,EAAE,EAAE;IAC5B,IAAI+D,KAAK,GAAGd,IAAI,CAACjD,CAAC,CAAC;IACnB,IAAI2E,MAAM,GAAGH,MAAM,GAAGxE,CAAC;IACvB,IAAI0B,eAAe,CAACiD,MAAM,CAAC,EACvB;IAEJ,IAAIZ,KAAK,IAAI,CAAC,EAAE;MACZ,IAAI,CAACzB,cAAc,CAACyB,KAAK,EAAEY,MAAM,CAAC;MAClCF,SAAS,GAAG,IAAI;IACpB,CAAC,MAAM,IAAIV,KAAK,IAAInE,UAAU,EAAE;MAC5B,IAAIgF,UAAU,GAAGhF,UAAU,GAAGmE,KAAK;MACnC,IAAI,CAACW,YAAY,CAACE,UAAU,CAAC,EAAE;QAAG;QAC9B,IAAIC,SAAS,GAAIF,MAAM,IAAI,CAAC,KAAM,CAAC,CAAC,CAAE;QACtC,IAAI,IAAI,CAAC5C,gBAAgB,CAAC6C,UAAU,EAAEC,SAAS,EAAEnD,eAAe,CAAC,EAC7D+C,SAAS,GAAG,IAAI,CAAC,KAEjBC,YAAY,CAACE,UAAU,CAAC,GAAG,IAAI;MACvC;IACJ,CAAC,MAAM,IAAIb,KAAK,IAAIpE,SAAS,EAAE;MAC3B,IAAI,CAAC0E,kBAAkB,CAAC,IAAI,CAAC5D,cAAc,CAACd,SAAS,GAAGoE,KAAK,CAAC,EAAEY,MAAM,CAAC;MACvEF,SAAS,GAAG,IAAI;IACpB;EACJ;EACA,OAAOA,SAAS;AACpB,CAAC;;AAID;;AAEA,SAAS9B,WAAWA,CAACmC,OAAO,EAAEC,KAAK,EAAE;EACjC;EACA,IAAI,CAACC,aAAa,GAAG,CAAC,CAAC;EACvB,IAAI,CAACC,MAAM,GAAGhB,SAAS;;EAEvB;EACA,IAAI,CAACzC,WAAW,GAAGuD,KAAK,CAACvD,WAAW;EACpC,IAAI,CAACC,cAAc,GAAGsD,KAAK,CAACtD,cAAc;EAC1C,IAAI,CAACgB,qBAAqB,GAAGsC,KAAK,CAACvC,SAAS;EAC5C,IAAI,CAAC5B,OAAO,GAAGmE,KAAK,CAACnE,OAAO;AAChC;AAEA+B,WAAW,CAACR,SAAS,CAAC+C,KAAK,GAAG,UAASC,GAAG,EAAE;EACxC,IAAIC,MAAM,GAAGhG,MAAM,CAACiG,KAAK,CAACF,GAAG,CAACzE,MAAM,IAAI,IAAI,CAACE,OAAO,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;IAC1DoE,aAAa,GAAG,IAAI,CAACA,aAAa;IAClCC,MAAM,GAAG,IAAI,CAACA,MAAM;IAAEK,QAAQ,GAAG,CAAC,CAAC;IACnCtF,CAAC,GAAG,CAAC;IAAEkB,CAAC,GAAG,CAAC;EAEhB,OAAO,IAAI,EAAE;IACT;IACA,IAAIoE,QAAQ,KAAK,CAAC,CAAC,EAAE;MACjB,IAAItF,CAAC,IAAImF,GAAG,CAACzE,MAAM,EAAE;MACrB,IAAIqD,KAAK,GAAGoB,GAAG,CAAC5C,UAAU,CAACvC,CAAC,EAAE,CAAC;IACnC,CAAC,MACI;MACD,IAAI+D,KAAK,GAAGuB,QAAQ;MACpBA,QAAQ,GAAG,CAAC,CAAC;IACjB;;IAEA;IACA,IAAI,MAAM,IAAIvB,KAAK,IAAIA,KAAK,GAAG,MAAM,EAAE;MAAE;MACrC,IAAIA,KAAK,GAAG,MAAM,EAAE;QAAE;QAClB,IAAIiB,aAAa,KAAK,CAAC,CAAC,EAAE;UACtBA,aAAa,GAAGjB,KAAK;UACrB;QACJ,CAAC,MAAM;UACHiB,aAAa,GAAGjB,KAAK;UACrB;UACAA,KAAK,GAAGtE,UAAU;QACtB;MACJ,CAAC,MAAM;QAAE;QACL,IAAIuF,aAAa,KAAK,CAAC,CAAC,EAAE;UACtBjB,KAAK,GAAG,OAAO,GAAG,CAACiB,aAAa,GAAG,MAAM,IAAI,KAAK,IAAIjB,KAAK,GAAG,MAAM,CAAC;UACrEiB,aAAa,GAAG,CAAC,CAAC;QACtB,CAAC,MAAM;UACH;UACAjB,KAAK,GAAGtE,UAAU;QACtB;MAEJ;IACJ,CAAC,MACI,IAAIuF,aAAa,KAAK,CAAC,CAAC,EAAE;MAC3B;MACAM,QAAQ,GAAGvB,KAAK;MAAEA,KAAK,GAAGtE,UAAU,CAAC,CAAC;MACtCuF,aAAa,GAAG,CAAC,CAAC;IACtB;;IAEA;IACA,IAAId,QAAQ,GAAGzE,UAAU;IACzB,IAAIwF,MAAM,KAAKhB,SAAS,IAAIF,KAAK,IAAItE,UAAU,EAAE;MAAE;MAC/C,IAAI8F,OAAO,GAAGN,MAAM,CAAClB,KAAK,CAAC;MAC3B,IAAI,OAAOwB,OAAO,KAAK,QAAQ,EAAE;QAAE;QAC/BN,MAAM,GAAGM,OAAO;QAChB;MAEJ,CAAC,MAAM,IAAI,OAAOA,OAAO,IAAI,QAAQ,EAAE;QAAE;QACrCrB,QAAQ,GAAGqB,OAAO;MAEtB,CAAC,MAAM,IAAIA,OAAO,IAAItB,SAAS,EAAE;QAAE;;QAE/B;QACAsB,OAAO,GAAGN,MAAM,CAAClF,QAAQ,CAAC;QAC1B,IAAIwF,OAAO,KAAKtB,SAAS,EAAE;UACvBC,QAAQ,GAAGqB,OAAO,CAAC,CAAC;UACpBD,QAAQ,GAAGvB,KAAK,CAAC,CAAC;QAEtB,CAAC,MAAM;UACH;UACA;UACA;UACA;QAAA;MAER;MACAkB,MAAM,GAAGhB,SAAS;IACtB,CAAC,MACI,IAAIF,KAAK,IAAI,CAAC,EAAE;MAAG;MACpB,IAAIyB,QAAQ,GAAG,IAAI,CAAChE,WAAW,CAACuC,KAAK,IAAI,CAAC,CAAC;MAC3C,IAAIyB,QAAQ,KAAKvB,SAAS,EACtBC,QAAQ,GAAGsB,QAAQ,CAACzB,KAAK,GAAG,IAAI,CAAC;MAErC,IAAIG,QAAQ,IAAIvE,SAAS,EAAE;QAAE;QACzBsF,MAAM,GAAG,IAAI,CAACxD,cAAc,CAAC9B,SAAS,GAACuE,QAAQ,CAAC;QAChD;MACJ;MAEA,IAAIA,QAAQ,IAAIzE,UAAU,IAAI,IAAI,CAACmB,OAAO,EAAE;QACxC;QACA,IAAI6E,GAAG,GAAGC,OAAO,CAAC,IAAI,CAAC9E,OAAO,CAAC+E,MAAM,EAAE5B,KAAK,CAAC;QAC7C,IAAI0B,GAAG,IAAI,CAAC,CAAC,EAAE;UACX,IAAIvB,QAAQ,GAAG,IAAI,CAACtD,OAAO,CAACgF,OAAO,CAACH,GAAG,CAAC,IAAI1B,KAAK,GAAG,IAAI,CAACnD,OAAO,CAAC+E,MAAM,CAACF,GAAG,CAAC,CAAC;UAC7EL,MAAM,CAAClE,CAAC,EAAE,CAAC,GAAG,IAAI,GAAG2E,IAAI,CAACC,KAAK,CAAC5B,QAAQ,GAAG,KAAK,CAAC;UAAEA,QAAQ,GAAGA,QAAQ,GAAG,KAAK;UAC9EkB,MAAM,CAAClE,CAAC,EAAE,CAAC,GAAG,IAAI,GAAG2E,IAAI,CAACC,KAAK,CAAC5B,QAAQ,GAAG,IAAI,CAAC;UAAEA,QAAQ,GAAGA,QAAQ,GAAG,IAAI;UAC5EkB,MAAM,CAAClE,CAAC,EAAE,CAAC,GAAG,IAAI,GAAG2E,IAAI,CAACC,KAAK,CAAC5B,QAAQ,GAAG,EAAE,CAAC;UAAEA,QAAQ,GAAGA,QAAQ,GAAG,EAAE;UACxEkB,MAAM,CAAClE,CAAC,EAAE,CAAC,GAAG,IAAI,GAAGgD,QAAQ;UAC7B;QACJ;MACJ;IACJ;;IAEA;IACA,IAAIA,QAAQ,KAAKzE,UAAU,EACvByE,QAAQ,GAAG,IAAI,CAACzB,qBAAqB;IAEzC,IAAIyB,QAAQ,GAAG,KAAK,EAAE;MAClBkB,MAAM,CAAClE,CAAC,EAAE,CAAC,GAAGgD,QAAQ;IAC1B,CAAC,MACI,IAAIA,QAAQ,GAAG,OAAO,EAAE;MACzBkB,MAAM,CAAClE,CAAC,EAAE,CAAC,GAAGgD,QAAQ,IAAI,CAAC,CAAC,CAAG;MAC/BkB,MAAM,CAAClE,CAAC,EAAE,CAAC,GAAGgD,QAAQ,GAAG,IAAI,CAAC,CAAC;IACnC,CAAC,MACI,IAAIA,QAAQ,GAAG,SAAS,EAAE;MAC3BkB,MAAM,CAAClE,CAAC,EAAE,CAAC,GAAGgD,QAAQ,IAAI,EAAE;MAC5BkB,MAAM,CAAClE,CAAC,EAAE,CAAC,GAAIgD,QAAQ,IAAI,CAAC,GAAI,IAAI;MACpCkB,MAAM,CAAClE,CAAC,EAAE,CAAC,GAAGgD,QAAQ,GAAG,IAAI;IACjC,CAAC,MAAM;MACHkB,MAAM,CAAClE,CAAC,EAAE,CAAC,GAAGgD,QAAQ,KAAK,EAAE;MAC7BkB,MAAM,CAAClE,CAAC,EAAE,CAAC,GAAIgD,QAAQ,KAAK,EAAE,GAAI,IAAI;MACtCkB,MAAM,CAAClE,CAAC,EAAE,CAAC,GAAIgD,QAAQ,KAAK,CAAC,GAAI,IAAI;MACrCkB,MAAM,CAAClE,CAAC,EAAE,CAAC,GAAGgD,QAAQ,GAAG,IAAI;IACjC;EACJ;EAEA,IAAI,CAACe,MAAM,GAAGA,MAAM;EACpB,IAAI,CAACD,aAAa,GAAGA,aAAa;EAClC,OAAOI,MAAM,CAAC5E,KAAK,CAAC,CAAC,EAAEU,CAAC,CAAC;AAC7B,CAAC;AAEDyB,WAAW,CAACR,SAAS,CAAC4D,GAAG,GAAG,YAAW;EACnC,IAAI,IAAI,CAACf,aAAa,KAAK,CAAC,CAAC,IAAI,IAAI,CAACC,MAAM,KAAKhB,SAAS,EACtD,OAAO,CAAC;;EAEZ,IAAImB,MAAM,GAAGhG,MAAM,CAACiG,KAAK,CAAC,EAAE,CAAC;IAAEnE,CAAC,GAAG,CAAC;EAEpC,IAAI,IAAI,CAAC+D,MAAM,EAAE;IAAE;IACf,IAAIf,QAAQ,GAAG,IAAI,CAACe,MAAM,CAAClF,QAAQ,CAAC;IACpC,IAAImE,QAAQ,KAAKD,SAAS,EAAE;MAAE;MAC1B,IAAIC,QAAQ,GAAG,KAAK,EAAE;QAClBkB,MAAM,CAAClE,CAAC,EAAE,CAAC,GAAGgD,QAAQ;MAC1B,CAAC,MACI;QACDkB,MAAM,CAAClE,CAAC,EAAE,CAAC,GAAGgD,QAAQ,IAAI,CAAC,CAAC,CAAG;QAC/BkB,MAAM,CAAClE,CAAC,EAAE,CAAC,GAAGgD,QAAQ,GAAG,IAAI,CAAC,CAAC;MACnC;IACJ,CAAC,MAAM;MACH;IAAA;IAEJ,IAAI,CAACe,MAAM,GAAGhB,SAAS;EAC3B;EAEA,IAAI,IAAI,CAACe,aAAa,KAAK,CAAC,CAAC,EAAE;IAC3B;IACAI,MAAM,CAAClE,CAAC,EAAE,CAAC,GAAG,IAAI,CAACuB,qBAAqB;IACxC,IAAI,CAACuC,aAAa,GAAG,CAAC,CAAC;EAC3B;EAEA,OAAOI,MAAM,CAAC5E,KAAK,CAAC,CAAC,EAAEU,CAAC,CAAC;AAC7B,CAAC;;AAED;AACAyB,WAAW,CAACR,SAAS,CAACuD,OAAO,GAAGA,OAAO;;AAGvC;;AAEA,SAAS7C,WAAWA,CAACiC,OAAO,EAAEC,KAAK,EAAE;EACjC;EACA,IAAI,CAACR,OAAO,GAAG,CAAC;EAChB,IAAI,CAACyB,SAAS,GAAG,EAAE;;EAEnB;EACA,IAAI,CAACzF,YAAY,GAAGwE,KAAK,CAACxE,YAAY;EACtC,IAAI,CAACE,cAAc,GAAGsE,KAAK,CAACtE,cAAc;EAC1C,IAAI,CAACc,kBAAkB,GAAGwD,KAAK,CAACxD,kBAAkB;EAClD,IAAI,CAACX,OAAO,GAAGmE,KAAK,CAACnE,OAAO;AAChC;AAEAiC,WAAW,CAACV,SAAS,CAAC+C,KAAK,GAAG,UAASe,GAAG,EAAE;EACxC,IAAIb,MAAM,GAAGhG,MAAM,CAACiG,KAAK,CAACY,GAAG,CAACvF,MAAM,GAAC,CAAC,CAAC;IACnC6D,OAAO,GAAG,IAAI,CAACA,OAAO;IACtByB,SAAS,GAAG,IAAI,CAACA,SAAS;IAAEE,UAAU,GAAG,IAAI,CAACF,SAAS,CAACtF,MAAM;IAC9DyF,QAAQ,GAAG,CAAC,IAAI,CAACH,SAAS,CAACtF,MAAM;IAAE;IACnCqD,KAAK;EAET,KAAK,IAAI/D,CAAC,GAAG,CAAC,EAAEkB,CAAC,GAAG,CAAC,EAAElB,CAAC,GAAGiG,GAAG,CAACvF,MAAM,EAAEV,CAAC,EAAE,EAAE;IACxC,IAAIoG,OAAO,GAAIpG,CAAC,IAAI,CAAC,GAAIiG,GAAG,CAACjG,CAAC,CAAC,GAAGgG,SAAS,CAAChG,CAAC,GAAGkG,UAAU,CAAC;;IAE3D;IACA,IAAInC,KAAK,GAAG,IAAI,CAACxD,YAAY,CAACgE,OAAO,CAAC,CAAC6B,OAAO,CAAC;IAE/C,IAAIrC,KAAK,IAAI,CAAC,EAAE;MACZ;IAAA,CACH,MACI,IAAIA,KAAK,KAAKtE,UAAU,EAAE;MAAE;MAC7B;MACAsE,KAAK,GAAG,IAAI,CAACxC,kBAAkB,CAACgB,UAAU,CAAC,CAAC,CAAC;MAC7CvC,CAAC,GAAGmG,QAAQ,CAAC,CAAC;IAClB,CAAC,MACI,IAAIpC,KAAK,KAAKrE,YAAY,EAAE;MAC7B,IAAIM,CAAC,IAAI,CAAC,EAAE;QACR,IAAIqG,GAAG,GAAG,CAACJ,GAAG,CAACjG,CAAC,GAAC,CAAC,CAAC,GAAC,IAAI,IAAE,KAAK,GAAG,CAACiG,GAAG,CAACjG,CAAC,GAAC,CAAC,CAAC,GAAC,IAAI,IAAE,IAAI,GAAG,CAACiG,GAAG,CAACjG,CAAC,GAAC,CAAC,CAAC,GAAC,IAAI,IAAE,EAAE,IAAIoG,OAAO,GAAC,IAAI,CAAC;MAChG,CAAC,MAAM;QACH,IAAIC,GAAG,GAAG,CAACL,SAAS,CAAChG,CAAC,GAAC,CAAC,GAACkG,UAAU,CAAC,GAAC,IAAI,IAAE,KAAK,GACtC,CAAC,CAAElG,CAAC,GAAC,CAAC,IAAI,CAAC,GAAIiG,GAAG,CAACjG,CAAC,GAAC,CAAC,CAAC,GAAGgG,SAAS,CAAChG,CAAC,GAAC,CAAC,GAACkG,UAAU,CAAC,IAAE,IAAI,IAAE,IAAI,GAC/D,CAAC,CAAElG,CAAC,GAAC,CAAC,IAAI,CAAC,GAAIiG,GAAG,CAACjG,CAAC,GAAC,CAAC,CAAC,GAAGgG,SAAS,CAAChG,CAAC,GAAC,CAAC,GAACkG,UAAU,CAAC,IAAE,IAAI,IAAE,EAAE,IAC5DE,OAAO,GAAC,IAAI,CAAC;MAC5B;MACA,IAAIX,GAAG,GAAGC,OAAO,CAAC,IAAI,CAAC9E,OAAO,CAACgF,OAAO,EAAES,GAAG,CAAC;MAC5CtC,KAAK,GAAG,IAAI,CAACnD,OAAO,CAAC+E,MAAM,CAACF,GAAG,CAAC,GAAGY,GAAG,GAAG,IAAI,CAACzF,OAAO,CAACgF,OAAO,CAACH,GAAG,CAAC;IACtE,CAAC,MACI,IAAI1B,KAAK,IAAInE,UAAU,EAAE;MAAE;MAC5B2E,OAAO,GAAG3E,UAAU,GAAGmE,KAAK;MAC5B;IACJ,CAAC,MACI,IAAIA,KAAK,IAAIpE,SAAS,EAAE;MAAE;MAC3B,IAAIgE,GAAG,GAAG,IAAI,CAAClD,cAAc,CAACd,SAAS,GAAGoE,KAAK,CAAC;MAChD,KAAK,IAAI3C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGuC,GAAG,CAACjD,MAAM,GAAG,CAAC,EAAEU,CAAC,EAAE,EAAE;QACrC2C,KAAK,GAAGJ,GAAG,CAACvC,CAAC,CAAC;QACdgE,MAAM,CAAClE,CAAC,EAAE,CAAC,GAAG6C,KAAK,GAAG,IAAI;QAC1BqB,MAAM,CAAClE,CAAC,EAAE,CAAC,GAAG6C,KAAK,IAAI,CAAC;MAC5B;MACAA,KAAK,GAAGJ,GAAG,CAACA,GAAG,CAACjD,MAAM,GAAC,CAAC,CAAC;IAC7B,CAAC,MAEG,MAAM,IAAIN,KAAK,CAAC,0DAA0D,GAAG2D,KAAK,GAAG,MAAM,GAAGQ,OAAO,GAAG,GAAG,GAAG6B,OAAO,CAAC;;IAE1H;IACA,IAAIrC,KAAK,IAAI,OAAO,EAAE;MAClBA,KAAK,IAAI,OAAO;MAChB,IAAIuC,SAAS,GAAG,MAAM,GAAIvC,KAAK,IAAI,EAAG;MACtCqB,MAAM,CAAClE,CAAC,EAAE,CAAC,GAAGoF,SAAS,GAAG,IAAI;MAC9BlB,MAAM,CAAClE,CAAC,EAAE,CAAC,GAAGoF,SAAS,IAAI,CAAC;MAE5BvC,KAAK,GAAG,MAAM,GAAIA,KAAK,GAAG,KAAM;IACpC;IACAqB,MAAM,CAAClE,CAAC,EAAE,CAAC,GAAG6C,KAAK,GAAG,IAAI;IAC1BqB,MAAM,CAAClE,CAAC,EAAE,CAAC,GAAG6C,KAAK,IAAI,CAAC;;IAExB;IACAQ,OAAO,GAAG,CAAC;IAAE4B,QAAQ,GAAGnG,CAAC,GAAC,CAAC;EAC/B;EAEA,IAAI,CAACuE,OAAO,GAAGA,OAAO;EACtB,IAAI,CAACyB,SAAS,GAAIG,QAAQ,IAAI,CAAC,GACzBrG,KAAK,CAACqC,SAAS,CAAC3B,KAAK,CAAC6B,IAAI,CAAC4D,GAAG,EAAEE,QAAQ,CAAC,GACzCH,SAAS,CAACxF,KAAK,CAAC2F,QAAQ,GAAGD,UAAU,CAAC,CAACK,MAAM,CAACzG,KAAK,CAACqC,SAAS,CAAC3B,KAAK,CAAC6B,IAAI,CAAC4D,GAAG,CAAC,CAAC;EAEpF,OAAOb,MAAM,CAAC5E,KAAK,CAAC,CAAC,EAAEU,CAAC,CAAC,CAACgC,QAAQ,CAAC,MAAM,CAAC;AAC9C,CAAC;AAEDL,WAAW,CAACV,SAAS,CAAC4D,GAAG,GAAG,YAAW;EACnC,IAAIS,GAAG,GAAG,EAAE;;EAEZ;EACA,OAAO,IAAI,CAACR,SAAS,CAACtF,MAAM,GAAG,CAAC,EAAE;IAC9B;IACA8F,GAAG,IAAI,IAAI,CAACjF,kBAAkB;IAC9B,IAAIkF,QAAQ,GAAG,IAAI,CAACT,SAAS,CAACxF,KAAK,CAAC,CAAC,CAAC;;IAEtC;IACA,IAAI,CAACwF,SAAS,GAAG,EAAE;IACnB,IAAI,CAACzB,OAAO,GAAG,CAAC;IAChB,IAAIkC,QAAQ,CAAC/F,MAAM,GAAG,CAAC,EACnB8F,GAAG,IAAI,IAAI,CAACtB,KAAK,CAACuB,QAAQ,CAAC;EACnC;EAEA,IAAI,CAACT,SAAS,GAAG,EAAE;EACnB,IAAI,CAACzB,OAAO,GAAG,CAAC;EAChB,OAAOiC,GAAG;AACd,CAAC;;AAED;AACA,SAASd,OAAOA,CAACrF,KAAK,EAAEuB,GAAG,EAAE;EACzB,IAAIvB,KAAK,CAAC,CAAC,CAAC,GAAGuB,GAAG,EACd,OAAO,CAAC,CAAC;EAEb,IAAIN,CAAC,GAAG,CAAC;IAAEoF,CAAC,GAAGrG,KAAK,CAACK,MAAM;EAC3B,OAAOY,CAAC,GAAGoF,CAAC,GAAC,CAAC,EAAE;IAAE;IACd,IAAIC,GAAG,GAAGrF,CAAC,IAAKoF,CAAC,GAACpF,CAAC,GAAC,CAAC,IAAK,CAAC,CAAC;IAC5B,IAAIjB,KAAK,CAACsG,GAAG,CAAC,IAAI/E,GAAG,EACjBN,CAAC,GAAGqF,GAAG,CAAC,KAERD,CAAC,GAAGC,GAAG;EACf;EACA,OAAOrF,CAAC;AACZ"},"metadata":{},"sourceType":"script","externalDependencies":[]}